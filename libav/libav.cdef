 enum AVSampleFormat {     AV_SAMPLE_FMT_NONE = -1,     AV_SAMPLE_FMT_U8,     AV_SAMPLE_FMT_S16,     AV_SAMPLE_FMT_S32,     AV_SAMPLE_FMT_FLT,     AV_SAMPLE_FMT_DBL,     AV_SAMPLE_FMT_U8P,     AV_SAMPLE_FMT_S16P,     AV_SAMPLE_FMT_S32P,     AV_SAMPLE_FMT_FLTP,     AV_SAMPLE_FMT_DBLP,     AV_SAMPLE_FMT_S64,     AV_SAMPLE_FMT_S64P,     AV_SAMPLE_FMT_NB };
 const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt);
 enum AVSampleFormat av_get_sample_fmt(const char *name);
 enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar);
 enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt);
 enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt);
 char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt);
 int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt);
 int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt);
 int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples,                                enum AVSampleFormat sample_fmt, int align);
 int av_samples_fill_arrays(uint8_t **audio_data, int *linesize,                            const uint8_t *buf,                            int nb_channels, int nb_samples,                            enum AVSampleFormat sample_fmt, int align);
 int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels,                      int nb_samples, enum AVSampleFormat sample_fmt, int align);
 int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels,                                        int nb_samples, enum AVSampleFormat sample_fmt, int align);
 int av_samples_copy(uint8_t * const *dst, uint8_t * const *src, int dst_offset,                     int src_offset, int nb_samples, int nb_channels,                     enum AVSampleFormat sample_fmt);
 int av_samples_set_silence(uint8_t * const *audio_data, int offset, int nb_samples,                            int nb_channels, enum AVSampleFormat sample_fmt);
 unsigned avutil_version(void);
 const char *av_version_info(void);
 const char *avutil_configuration(void);
 const char *avutil_license(void);
 enum AVMediaType {     AVMEDIA_TYPE_UNKNOWN = -1,     AVMEDIA_TYPE_VIDEO,     AVMEDIA_TYPE_AUDIO,     AVMEDIA_TYPE_DATA,     AVMEDIA_TYPE_SUBTITLE,     AVMEDIA_TYPE_ATTACHMENT,     AVMEDIA_TYPE_NB };
 const char *av_get_media_type_string(enum AVMediaType media_type);
 enum AVPictureType {     AV_PICTURE_TYPE_NONE = 0,     AV_PICTURE_TYPE_I,     AV_PICTURE_TYPE_P,     AV_PICTURE_TYPE_B,     AV_PICTURE_TYPE_S,     AV_PICTURE_TYPE_SI,     AV_PICTURE_TYPE_SP,     AV_PICTURE_TYPE_BI, };
 char av_get_picture_type_char(enum AVPictureType pict_type);
 int av_strerror(int errnum, char *errbuf, size_t errbuf_size);
 static inline char *av_make_error_string(char *errbuf, size_t errbuf_size, int errnum) {     av_strerror(errnum, errbuf, errbuf_size);     return errbuf; }
  int av_reallocp(void *ptr, size_t size);
 void *av_realloc_f(void *ptr, size_t nelem, size_t elsize);
 int av_reallocp_array(void *ptr, size_t nmemb, size_t size);
 void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size);
 void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size);
 void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size);
 void av_free(void *ptr);
 void av_freep(void *ptr);
 char *av_strdup(const char *s) ;
 char *av_strndup(const char *s, size_t len) ;
 void *av_memdup(const void *p, size_t size);
 void av_memcpy_backptr(uint8_t *dst, int back, int cnt);
 void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem);
  int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem);
 void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size,                        const uint8_t *elem_data);
 int av_size_mult(size_t a, size_t b, size_t *r);
 void av_max_alloc(size_t max);
  int av_log2(unsigned v);
  int av_log2_16bit(unsigned v);
 static  inline  int av_clip_c(int a, int amin, int amax) {     if (a < amin) return amin;     else if (a > amax) return amax;     else return a; }
 static  inline  int64_t av_clip64_c(int64_t a, int64_t amin, int64_t amax) {     if (a < amin) return amin;     else if (a > amax) return amax;     else return a; }
 static  inline  uint8_t av_clip_uint8_c(int a) {     if (a&(~0xFF)) return (~a)>>31;     else return a; }
 static  inline  int8_t av_clip_int8_c(int a) {     if ((a+0x80U) & ~0xFF) return (a>>31) ^ 0x7F;     else return a; }
 static  inline  uint16_t av_clip_uint16_c(int a) {     if (a&(~0xFFFF)) return (~a)>>31;     else return a; }
 static  inline  int16_t av_clip_int16_c(int a) {     if ((a+0x8000U) & ~0xFFFF) return (a>>31) ^ 0x7FFF;     else return a; }
 static  inline  int32_t av_clipl_int32_c(int64_t a) {     if ((a+0x80000000ULL) & ~0xFFFFFFFFULL) return (int32_t)((a>>63) ^ 0x7FFFFFFF);     else return (int32_t)a; }
 static  inline  int av_clip_intp2_c(int a, int p) {     if (((unsigned)a + (1U << p)) & ~((2U << p) - 1))         return (a >> 31) ^ ((1 << p) - 1);     else         return a; }
 static  inline  unsigned av_clip_uintp2_c(int a, int p) {     if (a & ~((1U<<p) - 1)) return (~a) >> 31 & ((1U<<p) - 1);     else return a; }
 static  inline  unsigned av_zero_extend_c(unsigned a, unsigned p) {     return a & ((1U << p) - 1); }
  static  inline  unsigned av_mod_uintp2_c(unsigned a, unsigned p) {     return av_zero_extend_c(a, p); }
 static  inline int av_sat_add32_c(int a, int b) {     return av_clipl_int32_c((int64_t)a + b); }
 static  inline int av_sat_dadd32_c(int a, int b) {     return av_sat_add32_c(a, av_sat_add32_c(b, b)); }
 static  inline int av_sat_sub32_c(int a, int b) {     return av_clipl_int32_c((int64_t)a - b); }
 static  inline int av_sat_dsub32_c(int a, int b) {     return av_sat_sub32_c(a, av_sat_add32_c(b, b)); }
 static  inline int64_t av_sat_add64_c(int64_t a, int64_t b) {     int64_t tmp;     return !__builtin_add_overflow(a, b, &tmp) ? tmp : (tmp < 0 ?                                                                   9223372036854775807LL                                                                             :                                                                               (-9223372036854775807LL - 1)                                                                                       ); }
 static  inline int64_t av_sat_sub64_c(int64_t a, int64_t b) {     int64_t tmp;     return !__builtin_sub_overflow(a, b, &tmp) ? tmp : (tmp < 0 ?                                                                   9223372036854775807LL                                                                             :                                                                               (-9223372036854775807LL - 1)                                                                                       ); }
 static  inline  float av_clipf_c(float a, float amin, float amax) {     return ((((a) > (amin) ? (a) : (amin))) > (amax) ? (amax) : (((a) > (amin) ? (a) : (amin)))); }
 static  inline  double av_clipd_c(double a, double amin, double amax) {     return ((((a) > (amin) ? (a) : (amin))) > (amax) ? (amax) : (((a) > (amin) ? (a) : (amin)))); }
 static  inline  int av_ceil_log2_c(int x) {     return av_log2((x - 1U) << 1); }
 static  inline  int av_popcount_c(uint32_t x) {     x -= (x >> 1) & 0x55555555;     x = (x & 0x33333333) + ((x >> 2) & 0x33333333);     x = (x + (x >> 4)) & 0x0F0F0F0F;     x += x >> 8;     return (x + (x >> 16)) & 0x3F; }
 static  inline  int av_popcount64_c(uint64_t x) {     return av_popcount_c((uint32_t)x) + av_popcount_c((uint32_t)(x >> 32)); }
 static  inline  int av_parity_c(uint32_t v) {     return av_popcount_c(v) & 1; }
 typedef struct AVRational{     int num;     int den; } AVRational;
 static inline AVRational av_make_q(int num, int den) {     AVRational r = { num, den };     return r; }
 static inline int av_cmp_q(AVRational a, AVRational b){     const int64_t tmp= a.num * (int64_t)b.den - b.num * (int64_t)a.den;     if(tmp) return (int)((tmp ^ a.den ^ b.den)>>63)|1;     else if(b.den && a.den) return 0;     else if(a.num && b.num) return (a.num>>31) - (b.num>>31);     else return                                    (-0x7fffffff - 1)                                          ; }
 static inline double av_q2d(AVRational a){     return a.num / (double) a.den; }
 int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max);
 AVRational av_mul_q(AVRational b, AVRational c) ;
 AVRational av_div_q(AVRational b, AVRational c) ;
 AVRational av_add_q(AVRational b, AVRational c) ;
 AVRational av_sub_q(AVRational b, AVRational c) ;
 static  inline AVRational av_inv_q(AVRational q) {     AVRational r = { q.den, q.num };     return r; }
 AVRational av_d2q(double d, int max) ;
 int av_nearer_q(AVRational q, AVRational q1, AVRational q2);
 int av_find_nearest_q_idx(AVRational q, const AVRational* q_list);
 uint32_t av_q2intfloat(AVRational q);
 AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def);
 union av_intfloat32 {     uint32_t i;     float f; };
 union av_intfloat64 {     uint64_t i;     double f; };
 static  inline float av_int2float(uint32_t i) {     union av_intfloat32 v;     v.i = i;     return v.f; }
 static  inline uint32_t av_float2int(float f) {     union av_intfloat32 v;     v.f = f;     return v.i; }
 static  inline double av_int2double(uint64_t i) {     union av_intfloat64 v;     v.i = i;     return v.f; }
 static  inline uint64_t av_double2int(double f) {     union av_intfloat64 v;     v.f = f;     return v.i; }
 enum AVRounding {     AV_ROUND_ZERO = 0,     AV_ROUND_INF = 1,     AV_ROUND_DOWN = 2,     AV_ROUND_UP = 3,     AV_ROUND_NEAR_INF = 5,     AV_ROUND_PASS_MINMAX = 8192, };
 int64_t  av_gcd(int64_t a, int64_t b);
 int64_t av_rescale(int64_t a, int64_t b, int64_t c) ;
 int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd) ;
 int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq) ;
 int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq,                          enum AVRounding rnd) ;
 int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b);
 int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod);
 int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb);
 int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc);
 double av_bessel_i0(double x);
 typedef enum {     AV_CLASS_CATEGORY_NA = 0,     AV_CLASS_CATEGORY_INPUT,     AV_CLASS_CATEGORY_OUTPUT,     AV_CLASS_CATEGORY_MUXER,     AV_CLASS_CATEGORY_DEMUXER,     AV_CLASS_CATEGORY_ENCODER,     AV_CLASS_CATEGORY_DECODER,     AV_CLASS_CATEGORY_FILTER,     AV_CLASS_CATEGORY_BITSTREAM_FILTER,     AV_CLASS_CATEGORY_SWSCALER,     AV_CLASS_CATEGORY_SWRESAMPLER,     AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,     AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT,     AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT,     AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT,     AV_CLASS_CATEGORY_DEVICE_OUTPUT,     AV_CLASS_CATEGORY_DEVICE_INPUT,     AV_CLASS_CATEGORY_NB }AVClassCategory;
 struct AVOptionRanges;
 typedef struct AVClass {     const char* class_name;     const char* (*item_name)(void* ctx);     const struct AVOption *option;     int version;     int log_level_offset_offset;     int parent_log_context_offset;     AVClassCategory category;     AVClassCategory (*get_category)(void* ctx);     int (*query_ranges)(struct AVOptionRanges **, void *obj, const char *key, int flags);     void* (*child_next)(void *obj, void *prev);     const struct AVClass* (*child_class_iterate)(void **iter); } AVClass;
 void av_vlog(void *avcl, int level, const char *fmt, va_list vl);
 int av_log_get_level(void);
 void av_log_set_level(int level);
 void av_log_set_callback(void (*callback)(void*, int, const char*, va_list));
 void av_log_default_callback(void *avcl, int level, const char *fmt,                              va_list vl);
 const char* av_default_item_name(void* ctx);
 AVClassCategory av_default_get_category(void *ptr);
 void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl,                         char *line, int line_size, int *print_prefix);
 int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl,                         char *line, int line_size, int *print_prefix);
 void av_log_set_flags(int arg);
 int av_log_get_flags(void);
 enum AVPixelFormat {     AV_PIX_FMT_NONE = -1,     AV_PIX_FMT_YUV420P,     AV_PIX_FMT_YUYV422,     AV_PIX_FMT_RGB24,     AV_PIX_FMT_BGR24,     AV_PIX_FMT_YUV422P,     AV_PIX_FMT_YUV444P,     AV_PIX_FMT_YUV410P,     AV_PIX_FMT_YUV411P,     AV_PIX_FMT_GRAY8,     AV_PIX_FMT_MONOWHITE,     AV_PIX_FMT_MONOBLACK,     AV_PIX_FMT_PAL8,     AV_PIX_FMT_YUVJ420P,     AV_PIX_FMT_YUVJ422P,     AV_PIX_FMT_YUVJ444P,     AV_PIX_FMT_UYVY422,     AV_PIX_FMT_UYYVYY411,     AV_PIX_FMT_BGR8,     AV_PIX_FMT_BGR4,     AV_PIX_FMT_BGR4_BYTE,     AV_PIX_FMT_RGB8,     AV_PIX_FMT_RGB4,     AV_PIX_FMT_RGB4_BYTE,     AV_PIX_FMT_NV12,     AV_PIX_FMT_NV21,     AV_PIX_FMT_ARGB,     AV_PIX_FMT_RGBA,     AV_PIX_FMT_ABGR,     AV_PIX_FMT_BGRA,     AV_PIX_FMT_GRAY16BE,     AV_PIX_FMT_GRAY16LE,     AV_PIX_FMT_YUV440P,     AV_PIX_FMT_YUVJ440P,     AV_PIX_FMT_YUVA420P,     AV_PIX_FMT_RGB48BE,     AV_PIX_FMT_RGB48LE,     AV_PIX_FMT_RGB565BE,     AV_PIX_FMT_RGB565LE,     AV_PIX_FMT_RGB555BE,     AV_PIX_FMT_RGB555LE,     AV_PIX_FMT_BGR565BE,     AV_PIX_FMT_BGR565LE,     AV_PIX_FMT_BGR555BE,     AV_PIX_FMT_BGR555LE,     AV_PIX_FMT_VAAPI,     AV_PIX_FMT_YUV420P16LE,     AV_PIX_FMT_YUV420P16BE,     AV_PIX_FMT_YUV422P16LE,     AV_PIX_FMT_YUV422P16BE,     AV_PIX_FMT_YUV444P16LE,     AV_PIX_FMT_YUV444P16BE,     AV_PIX_FMT_DXVA2_VLD,     AV_PIX_FMT_RGB444LE,     AV_PIX_FMT_RGB444BE,     AV_PIX_FMT_BGR444LE,     AV_PIX_FMT_BGR444BE,     AV_PIX_FMT_YA8,     AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8,     AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8,     AV_PIX_FMT_BGR48BE,     AV_PIX_FMT_BGR48LE,     AV_PIX_FMT_YUV420P9BE,     AV_PIX_FMT_YUV420P9LE,     AV_PIX_FMT_YUV420P10BE,     AV_PIX_FMT_YUV420P10LE,     AV_PIX_FMT_YUV422P10BE,     AV_PIX_FMT_YUV422P10LE,     AV_PIX_FMT_YUV444P9BE,     AV_PIX_FMT_YUV444P9LE,     AV_PIX_FMT_YUV444P10BE,     AV_PIX_FMT_YUV444P10LE,     AV_PIX_FMT_YUV422P9BE,     AV_PIX_FMT_YUV422P9LE,     AV_PIX_FMT_GBRP,     AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP,     AV_PIX_FMT_GBRP9BE,     AV_PIX_FMT_GBRP9LE,     AV_PIX_FMT_GBRP10BE,     AV_PIX_FMT_GBRP10LE,     AV_PIX_FMT_GBRP16BE,     AV_PIX_FMT_GBRP16LE,     AV_PIX_FMT_YUVA422P,     AV_PIX_FMT_YUVA444P,     AV_PIX_FMT_YUVA420P9BE,     AV_PIX_FMT_YUVA420P9LE,     AV_PIX_FMT_YUVA422P9BE,     AV_PIX_FMT_YUVA422P9LE,     AV_PIX_FMT_YUVA444P9BE,     AV_PIX_FMT_YUVA444P9LE,     AV_PIX_FMT_YUVA420P10BE,     AV_PIX_FMT_YUVA420P10LE,     AV_PIX_FMT_YUVA422P10BE,     AV_PIX_FMT_YUVA422P10LE,     AV_PIX_FMT_YUVA444P10BE,     AV_PIX_FMT_YUVA444P10LE,     AV_PIX_FMT_YUVA420P16BE,     AV_PIX_FMT_YUVA420P16LE,     AV_PIX_FMT_YUVA422P16BE,     AV_PIX_FMT_YUVA422P16LE,     AV_PIX_FMT_YUVA444P16BE,     AV_PIX_FMT_YUVA444P16LE,     AV_PIX_FMT_VDPAU,     AV_PIX_FMT_XYZ12LE,     AV_PIX_FMT_XYZ12BE,     AV_PIX_FMT_NV16,     AV_PIX_FMT_NV20LE,     AV_PIX_FMT_NV20BE,     AV_PIX_FMT_RGBA64BE,     AV_PIX_FMT_RGBA64LE,     AV_PIX_FMT_BGRA64BE,     AV_PIX_FMT_BGRA64LE,     AV_PIX_FMT_YVYU422,     AV_PIX_FMT_YA16BE,     AV_PIX_FMT_YA16LE,     AV_PIX_FMT_GBRAP,     AV_PIX_FMT_GBRAP16BE,     AV_PIX_FMT_GBRAP16LE,     AV_PIX_FMT_QSV,     AV_PIX_FMT_MMAL,     AV_PIX_FMT_D3D11VA_VLD,     AV_PIX_FMT_CUDA,     AV_PIX_FMT_0RGB,     AV_PIX_FMT_RGB0,     AV_PIX_FMT_0BGR,     AV_PIX_FMT_BGR0,     AV_PIX_FMT_YUV420P12BE,     AV_PIX_FMT_YUV420P12LE,     AV_PIX_FMT_YUV420P14BE,     AV_PIX_FMT_YUV420P14LE,     AV_PIX_FMT_YUV422P12BE,     AV_PIX_FMT_YUV422P12LE,     AV_PIX_FMT_YUV422P14BE,     AV_PIX_FMT_YUV422P14LE,     AV_PIX_FMT_YUV444P12BE,     AV_PIX_FMT_YUV444P12LE,     AV_PIX_FMT_YUV444P14BE,     AV_PIX_FMT_YUV444P14LE,     AV_PIX_FMT_GBRP12BE,     AV_PIX_FMT_GBRP12LE,     AV_PIX_FMT_GBRP14BE,     AV_PIX_FMT_GBRP14LE,     AV_PIX_FMT_YUVJ411P,     AV_PIX_FMT_BAYER_BGGR8,     AV_PIX_FMT_BAYER_RGGB8,     AV_PIX_FMT_BAYER_GBRG8,     AV_PIX_FMT_BAYER_GRBG8,     AV_PIX_FMT_BAYER_BGGR16LE,     AV_PIX_FMT_BAYER_BGGR16BE,     AV_PIX_FMT_BAYER_RGGB16LE,     AV_PIX_FMT_BAYER_RGGB16BE,     AV_PIX_FMT_BAYER_GBRG16LE,     AV_PIX_FMT_BAYER_GBRG16BE,     AV_PIX_FMT_BAYER_GRBG16LE,     AV_PIX_FMT_BAYER_GRBG16BE,     AV_PIX_FMT_YUV440P10LE,     AV_PIX_FMT_YUV440P10BE,     AV_PIX_FMT_YUV440P12LE,     AV_PIX_FMT_YUV440P12BE,     AV_PIX_FMT_AYUV64LE,     AV_PIX_FMT_AYUV64BE,     AV_PIX_FMT_VIDEOTOOLBOX,     AV_PIX_FMT_P010LE,     AV_PIX_FMT_P010BE,     AV_PIX_FMT_GBRAP12BE,     AV_PIX_FMT_GBRAP12LE,     AV_PIX_FMT_GBRAP10BE,     AV_PIX_FMT_GBRAP10LE,     AV_PIX_FMT_MEDIACODEC,     AV_PIX_FMT_GRAY12BE,     AV_PIX_FMT_GRAY12LE,     AV_PIX_FMT_GRAY10BE,     AV_PIX_FMT_GRAY10LE,     AV_PIX_FMT_P016LE,     AV_PIX_FMT_P016BE,     AV_PIX_FMT_D3D11,     AV_PIX_FMT_GRAY9BE,     AV_PIX_FMT_GRAY9LE,     AV_PIX_FMT_GBRPF32BE,     AV_PIX_FMT_GBRPF32LE,     AV_PIX_FMT_GBRAPF32BE,     AV_PIX_FMT_GBRAPF32LE,     AV_PIX_FMT_DRM_PRIME,     AV_PIX_FMT_OPENCL,     AV_PIX_FMT_GRAY14BE,     AV_PIX_FMT_GRAY14LE,     AV_PIX_FMT_GRAYF32BE,     AV_PIX_FMT_GRAYF32LE,     AV_PIX_FMT_YUVA422P12BE,     AV_PIX_FMT_YUVA422P12LE,     AV_PIX_FMT_YUVA444P12BE,     AV_PIX_FMT_YUVA444P12LE,     AV_PIX_FMT_NV24,     AV_PIX_FMT_NV42,     AV_PIX_FMT_VULKAN,     AV_PIX_FMT_Y210BE,     AV_PIX_FMT_Y210LE,     AV_PIX_FMT_X2RGB10LE,     AV_PIX_FMT_X2RGB10BE,     AV_PIX_FMT_X2BGR10LE,     AV_PIX_FMT_X2BGR10BE,     AV_PIX_FMT_P210BE,     AV_PIX_FMT_P210LE,     AV_PIX_FMT_P410BE,     AV_PIX_FMT_P410LE,     AV_PIX_FMT_P216BE,     AV_PIX_FMT_P216LE,     AV_PIX_FMT_P416BE,     AV_PIX_FMT_P416LE,     AV_PIX_FMT_VUYA,     AV_PIX_FMT_RGBAF16BE,     AV_PIX_FMT_RGBAF16LE,     AV_PIX_FMT_VUYX,     AV_PIX_FMT_P012LE,     AV_PIX_FMT_P012BE,     AV_PIX_FMT_Y212BE,     AV_PIX_FMT_Y212LE,     AV_PIX_FMT_XV30BE,     AV_PIX_FMT_XV30LE,     AV_PIX_FMT_XV36BE,     AV_PIX_FMT_XV36LE,     AV_PIX_FMT_RGBF32BE,     AV_PIX_FMT_RGBF32LE,     AV_PIX_FMT_RGBAF32BE,     AV_PIX_FMT_RGBAF32LE,     AV_PIX_FMT_P212BE,     AV_PIX_FMT_P212LE,     AV_PIX_FMT_P412BE,     AV_PIX_FMT_P412LE,     AV_PIX_FMT_GBRAP14BE,     AV_PIX_FMT_GBRAP14LE,     AV_PIX_FMT_D3D12,     AV_PIX_FMT_NB };
 enum AVColorPrimaries {     AVCOL_PRI_RESERVED0 = 0,     AVCOL_PRI_BT709 = 1,     AVCOL_PRI_UNSPECIFIED = 2,     AVCOL_PRI_RESERVED = 3,     AVCOL_PRI_BT470M = 4,     AVCOL_PRI_BT470BG = 5,     AVCOL_PRI_SMPTE170M = 6,     AVCOL_PRI_SMPTE240M = 7,     AVCOL_PRI_FILM = 8,     AVCOL_PRI_BT2020 = 9,     AVCOL_PRI_SMPTE428 = 10,     AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,     AVCOL_PRI_SMPTE431 = 11,     AVCOL_PRI_SMPTE432 = 12,     AVCOL_PRI_EBU3213 = 22,     AVCOL_PRI_JEDEC_P22 = AVCOL_PRI_EBU3213,     AVCOL_PRI_NB };
 enum AVColorTransferCharacteristic {     AVCOL_TRC_RESERVED0 = 0,     AVCOL_TRC_BT709 = 1,     AVCOL_TRC_UNSPECIFIED = 2,     AVCOL_TRC_RESERVED = 3,     AVCOL_TRC_GAMMA22 = 4,     AVCOL_TRC_GAMMA28 = 5,     AVCOL_TRC_SMPTE170M = 6,     AVCOL_TRC_SMPTE240M = 7,     AVCOL_TRC_LINEAR = 8,     AVCOL_TRC_LOG = 9,     AVCOL_TRC_LOG_SQRT = 10,     AVCOL_TRC_IEC61966_2_4 = 11,     AVCOL_TRC_BT1361_ECG = 12,     AVCOL_TRC_IEC61966_2_1 = 13,     AVCOL_TRC_BT2020_10 = 14,     AVCOL_TRC_BT2020_12 = 15,     AVCOL_TRC_SMPTE2084 = 16,     AVCOL_TRC_SMPTEST2084 = AVCOL_TRC_SMPTE2084,     AVCOL_TRC_SMPTE428 = 17,     AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,     AVCOL_TRC_ARIB_STD_B67 = 18,     AVCOL_TRC_NB };
 enum AVColorSpace {     AVCOL_SPC_RGB = 0,     AVCOL_SPC_BT709 = 1,     AVCOL_SPC_UNSPECIFIED = 2,     AVCOL_SPC_RESERVED = 3,     AVCOL_SPC_FCC = 4,     AVCOL_SPC_BT470BG = 5,     AVCOL_SPC_SMPTE170M = 6,     AVCOL_SPC_SMPTE240M = 7,     AVCOL_SPC_YCGCO = 8,     AVCOL_SPC_YCOCG = AVCOL_SPC_YCGCO,     AVCOL_SPC_BT2020_NCL = 9,     AVCOL_SPC_BT2020_CL = 10,     AVCOL_SPC_SMPTE2085 = 11,     AVCOL_SPC_CHROMA_DERIVED_NCL = 12,     AVCOL_SPC_CHROMA_DERIVED_CL = 13,     AVCOL_SPC_ICTCP = 14,     AVCOL_SPC_IPT_C2 = 15,     AVCOL_SPC_YCGCO_RE = 16,     AVCOL_SPC_YCGCO_RO = 17,     AVCOL_SPC_NB };
 enum AVColorRange {     AVCOL_RANGE_UNSPECIFIED = 0,     AVCOL_RANGE_MPEG = 1,     AVCOL_RANGE_JPEG = 2,     AVCOL_RANGE_NB };
 enum AVChromaLocation {     AVCHROMA_LOC_UNSPECIFIED = 0,     AVCHROMA_LOC_LEFT = 1,     AVCHROMA_LOC_CENTER = 2,     AVCHROMA_LOC_TOPLEFT = 3,     AVCHROMA_LOC_TOP = 4,     AVCHROMA_LOC_BOTTOMLEFT = 5,     AVCHROMA_LOC_BOTTOM = 6,     AVCHROMA_LOC_NB };
 static inline void *av_x_if_null(const void *p, const void *x) {     return (void *)(intptr_t)(p ? p : x); }
 unsigned av_int_list_length_for_size(unsigned elsize,                                      const void *list, uint64_t term) ;
 AVRational av_get_time_base_q(void);
 char *av_fourcc_make_string(char *buf, uint32_t fourcc);
 typedef struct AVBuffer AVBuffer;
 typedef struct AVBufferRef {     AVBuffer *buffer;     uint8_t *data;     size_t size; } AVBufferRef;
 AVBufferRef *av_buffer_alloc(size_t size);
 AVBufferRef *av_buffer_allocz(size_t size);
 AVBufferRef *av_buffer_create(uint8_t *data, size_t size,                               void (*free)(void *opaque, uint8_t *data),                               void *opaque, int flags);
 void av_buffer_default_free(void *opaque, uint8_t *data);
 AVBufferRef *av_buffer_ref(const AVBufferRef *buf);
 void av_buffer_unref(AVBufferRef **buf);
 int av_buffer_is_writable(const AVBufferRef *buf);
 void *av_buffer_get_opaque(const AVBufferRef *buf);
 int av_buffer_get_ref_count(const AVBufferRef *buf);
 int av_buffer_make_writable(AVBufferRef **buf);
 int av_buffer_realloc(AVBufferRef **buf, size_t size);
 int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src);
 typedef struct AVBufferPool AVBufferPool;
 AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef* (*alloc)(size_t size));
 AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque,                                    AVBufferRef* (*alloc)(void *opaque, size_t size),                                    void (*pool_free)(void *opaque));
 void av_buffer_pool_uninit(AVBufferPool **pool);
 AVBufferRef *av_buffer_pool_get(AVBufferPool *pool);
 void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref);
 enum AVChannel {     AV_CHAN_NONE = -1,     AV_CHAN_FRONT_LEFT,     AV_CHAN_FRONT_RIGHT,     AV_CHAN_FRONT_CENTER,     AV_CHAN_LOW_FREQUENCY,     AV_CHAN_BACK_LEFT,     AV_CHAN_BACK_RIGHT,     AV_CHAN_FRONT_LEFT_OF_CENTER,     AV_CHAN_FRONT_RIGHT_OF_CENTER,     AV_CHAN_BACK_CENTER,     AV_CHAN_SIDE_LEFT,     AV_CHAN_SIDE_RIGHT,     AV_CHAN_TOP_CENTER,     AV_CHAN_TOP_FRONT_LEFT,     AV_CHAN_TOP_FRONT_CENTER,     AV_CHAN_TOP_FRONT_RIGHT,     AV_CHAN_TOP_BACK_LEFT,     AV_CHAN_TOP_BACK_CENTER,     AV_CHAN_TOP_BACK_RIGHT,     AV_CHAN_STEREO_LEFT = 29,     AV_CHAN_STEREO_RIGHT,     AV_CHAN_WIDE_LEFT,     AV_CHAN_WIDE_RIGHT,     AV_CHAN_SURROUND_DIRECT_LEFT,     AV_CHAN_SURROUND_DIRECT_RIGHT,     AV_CHAN_LOW_FREQUENCY_2,     AV_CHAN_TOP_SIDE_LEFT,     AV_CHAN_TOP_SIDE_RIGHT,     AV_CHAN_BOTTOM_FRONT_CENTER,     AV_CHAN_BOTTOM_FRONT_LEFT,     AV_CHAN_BOTTOM_FRONT_RIGHT,     AV_CHAN_SIDE_SURROUND_LEFT,     AV_CHAN_SIDE_SURROUND_RIGHT,     AV_CHAN_TOP_SURROUND_LEFT,     AV_CHAN_TOP_SURROUND_RIGHT,     AV_CHAN_UNUSED = 0x200,     AV_CHAN_UNKNOWN = 0x300,     AV_CHAN_AMBISONIC_BASE = 0x400,     AV_CHAN_AMBISONIC_END = 0x7ff, };
 enum AVChannelOrder {     AV_CHANNEL_ORDER_UNSPEC,     AV_CHANNEL_ORDER_NATIVE,     AV_CHANNEL_ORDER_CUSTOM,     AV_CHANNEL_ORDER_AMBISONIC,     FF_CHANNEL_ORDER_NB };
 enum AVMatrixEncoding {     AV_MATRIX_ENCODING_NONE,     AV_MATRIX_ENCODING_DOLBY,     AV_MATRIX_ENCODING_DPLII,     AV_MATRIX_ENCODING_DPLIIX,     AV_MATRIX_ENCODING_DPLIIZ,     AV_MATRIX_ENCODING_DOLBYEX,     AV_MATRIX_ENCODING_DOLBYHEADPHONE,     AV_MATRIX_ENCODING_NB };
 typedef struct AVChannelCustom {     enum AVChannel id;     char name[16];     void *opaque; } AVChannelCustom;
 typedef struct AVChannelLayout {     enum AVChannelOrder order;     int nb_channels;     union {         uint64_t mask;         AVChannelCustom *map;     } u;     void *opaque; } AVChannelLayout;
 struct AVBPrint;
 int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel);
 void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id);
 int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel);
 void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id);
 enum AVChannel av_channel_from_string(const char *name);
 int av_channel_layout_custom_init(AVChannelLayout *channel_layout, int nb_channels);
 int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask);
 int av_channel_layout_from_string(AVChannelLayout *channel_layout,                                   const char *str);
 void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels);
 const AVChannelLayout *av_channel_layout_standard(void **opaque);
 void av_channel_layout_uninit(AVChannelLayout *channel_layout);
 int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src);
 int av_channel_layout_describe(const AVChannelLayout *channel_layout,                                char *buf, size_t buf_size);
 int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout,                                       struct AVBPrint *bp);
 enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx);
 int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout,                                          enum AVChannel channel);
 int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout,                                         const char *name);
 enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout,                                       const char *name);
 uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout,                                   uint64_t mask);
 int av_channel_layout_check(const AVChannelLayout *channel_layout);
 int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1);
 int av_channel_layout_ambisonic_order(const AVChannelLayout *channel_layout);
 int av_channel_layout_retype(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags);
 typedef struct AVDictionaryEntry {     char *key;     char *value; } AVDictionaryEntry;
 typedef struct AVDictionary AVDictionary;
 AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key,                                const AVDictionaryEntry *prev, int flags);
 const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m,                                          const AVDictionaryEntry *prev);
 int av_dict_count(const AVDictionary *m);
 int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags);
 int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags);
 int av_dict_parse_string(AVDictionary **pm, const char *str,                          const char *key_val_sep, const char *pairs_sep,                          int flags);
 int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags);
 void av_dict_free(AVDictionary **m);
 int av_dict_get_string(const AVDictionary *m, char **buffer,                        const char key_val_sep, const char pairs_sep);
 enum AVFrameSideDataType {     AV_FRAME_DATA_PANSCAN,     AV_FRAME_DATA_A53_CC,     AV_FRAME_DATA_STEREO3D,     AV_FRAME_DATA_MATRIXENCODING,     AV_FRAME_DATA_DOWNMIX_INFO,     AV_FRAME_DATA_REPLAYGAIN,     AV_FRAME_DATA_DISPLAYMATRIX,     AV_FRAME_DATA_AFD,     AV_FRAME_DATA_MOTION_VECTORS,     AV_FRAME_DATA_SKIP_SAMPLES,     AV_FRAME_DATA_AUDIO_SERVICE_TYPE,     AV_FRAME_DATA_MASTERING_DISPLAY_METADATA,     AV_FRAME_DATA_GOP_TIMECODE,     AV_FRAME_DATA_SPHERICAL,     AV_FRAME_DATA_CONTENT_LIGHT_LEVEL,     AV_FRAME_DATA_ICC_PROFILE,     AV_FRAME_DATA_S12M_TIMECODE,     AV_FRAME_DATA_DYNAMIC_HDR_PLUS,     AV_FRAME_DATA_REGIONS_OF_INTEREST,     AV_FRAME_DATA_VIDEO_ENC_PARAMS,     AV_FRAME_DATA_SEI_UNREGISTERED,     AV_FRAME_DATA_FILM_GRAIN_PARAMS,     AV_FRAME_DATA_DETECTION_BBOXES,     AV_FRAME_DATA_DOVI_RPU_BUFFER,     AV_FRAME_DATA_DOVI_METADATA,     AV_FRAME_DATA_DYNAMIC_HDR_VIVID,     AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT,     AV_FRAME_DATA_VIDEO_HINT,     AV_FRAME_DATA_LCEVC,     AV_FRAME_DATA_VIEW_ID, };
 enum AVActiveFormatDescription {     AV_AFD_SAME = 8,     AV_AFD_4_3 = 9,     AV_AFD_16_9 = 10,     AV_AFD_14_9 = 11,     AV_AFD_4_3_SP_14_9 = 13,     AV_AFD_16_9_SP_14_9 = 14,     AV_AFD_SP_4_3 = 15, };
 typedef struct AVFrameSideData {     enum AVFrameSideDataType type;     uint8_t *data;     size_t size;     AVDictionary *metadata;     AVBufferRef *buf; } AVFrameSideData;
 enum AVSideDataProps {     AV_SIDE_DATA_PROP_GLOBAL = (1 << 0),     AV_SIDE_DATA_PROP_MULTI = (1 << 1), };
 typedef struct AVSideDataDescriptor {     const char *name;     unsigned props; } AVSideDataDescriptor;
 typedef struct AVRegionOfInterest {     uint32_t self_size;     int top;     int bottom;     int left;     int right;     AVRational qoffset; } AVRegionOfInterest;
 typedef struct AVFrame {     uint8_t *data[8];     int linesize[8];     uint8_t **extended_data;     int width, height;     int nb_samples;     int format;          int key_frame;     enum AVPictureType pict_type;     AVRational sample_aspect_ratio;     int64_t pts;     int64_t pkt_dts;     AVRational time_base;     int quality;     void *opaque;     int repeat_pict;          int interlaced_frame;          int top_field_first;          int palette_has_changed;     int sample_rate;     AVBufferRef *buf[8];     AVBufferRef **extended_buf;     int nb_extended_buf;     AVFrameSideData **side_data;     int nb_side_data;     int flags;     enum AVColorRange color_range;     enum AVColorPrimaries color_primaries;     enum AVColorTransferCharacteristic color_trc;     enum AVColorSpace colorspace;     enum AVChromaLocation chroma_location;     int64_t best_effort_timestamp;          int64_t pkt_pos;     AVDictionary *metadata;     int decode_error_flags;          int pkt_size;     AVBufferRef *hw_frames_ctx;     AVBufferRef *opaque_ref;     size_t crop_top;     size_t crop_bottom;     size_t crop_left;     size_t crop_right;     AVBufferRef *private_ref;     AVChannelLayout ch_layout;     int64_t duration; } AVFrame;
 AVFrame *av_frame_alloc(void);
 void av_frame_free(AVFrame **frame);
 int av_frame_ref(AVFrame *dst, const AVFrame *src);
 int av_frame_replace(AVFrame *dst, const AVFrame *src);
 AVFrame *av_frame_clone(const AVFrame *src);
 void av_frame_unref(AVFrame *frame);
 void av_frame_move_ref(AVFrame *dst, AVFrame *src);
 int av_frame_get_buffer(AVFrame *frame, int align);
 int av_frame_is_writable(AVFrame *frame);
 int av_frame_make_writable(AVFrame *frame);
 int av_frame_copy(AVFrame *dst, const AVFrame *src);
 int av_frame_copy_props(AVFrame *dst, const AVFrame *src);
 AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane);
 AVFrameSideData *av_frame_new_side_data(AVFrame *frame,                                         enum AVFrameSideDataType type,                                         size_t size);
 AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame,                                                  enum AVFrameSideDataType type,                                                  AVBufferRef *buf);
 AVFrameSideData *av_frame_get_side_data(const AVFrame *frame,                                         enum AVFrameSideDataType type);
 void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type);
 enum {     AV_FRAME_CROP_UNALIGNED = 1 << 0, };
 int av_frame_apply_cropping(AVFrame *frame, int flags);
 const char *av_frame_side_data_name(enum AVFrameSideDataType type);
 const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type);
 void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd);
 AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd,                                         enum AVFrameSideDataType type,                                         size_t size, unsigned int flags);
 AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd,                                         enum AVFrameSideDataType type,                                         AVBufferRef **buf, unsigned int flags);
 int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd,                              const AVFrameSideData *src, unsigned int flags);
 const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData * const *sd,                                                 const int nb_sd,                                                 enum AVFrameSideDataType type);
 static inline const AVFrameSideData *av_frame_side_data_get(AVFrameSideData * const *sd,                                               const int nb_sd,                                               enum AVFrameSideDataType type) {     return av_frame_side_data_get_c((const AVFrameSideData * const *)sd,                                     nb_sd, type); }
 void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd,                                enum AVFrameSideDataType type);
 enum AVHWDeviceType {     AV_HWDEVICE_TYPE_NONE,     AV_HWDEVICE_TYPE_VDPAU,     AV_HWDEVICE_TYPE_CUDA,     AV_HWDEVICE_TYPE_VAAPI,     AV_HWDEVICE_TYPE_DXVA2,     AV_HWDEVICE_TYPE_QSV,     AV_HWDEVICE_TYPE_VIDEOTOOLBOX,     AV_HWDEVICE_TYPE_D3D11VA,     AV_HWDEVICE_TYPE_DRM,     AV_HWDEVICE_TYPE_OPENCL,     AV_HWDEVICE_TYPE_MEDIACODEC,     AV_HWDEVICE_TYPE_VULKAN,     AV_HWDEVICE_TYPE_D3D12VA, };
 typedef struct AVHWDeviceContext {     const AVClass *av_class;     enum AVHWDeviceType type;     void *hwctx;     void (*free)(struct AVHWDeviceContext *ctx);     void *user_opaque; } AVHWDeviceContext;
 typedef struct AVHWFramesContext {     const AVClass *av_class;     AVBufferRef *device_ref;     AVHWDeviceContext *device_ctx;     void *hwctx;     void (*free)(struct AVHWFramesContext *ctx);     void *user_opaque;     AVBufferPool *pool;     int initial_pool_size;     enum AVPixelFormat format;     enum AVPixelFormat sw_format;     int width, height; } AVHWFramesContext;
 enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name);
 const char *av_hwdevice_get_type_name(enum AVHWDeviceType type);
 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev);
 AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type);
 int av_hwdevice_ctx_init(AVBufferRef *ref);
 int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type,                            const char *device, AVDictionary *opts, int flags);
 int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx,                                    enum AVHWDeviceType type,                                    AVBufferRef *src_ctx, int flags);
 int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx,                                         enum AVHWDeviceType type,                                         AVBufferRef *src_ctx,                                         AVDictionary *options, int flags);
 AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx);
 int av_hwframe_ctx_init(AVBufferRef *ref);
 int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags);
 int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags);
 enum AVHWFrameTransferDirection {     AV_HWFRAME_TRANSFER_DIRECTION_FROM,     AV_HWFRAME_TRANSFER_DIRECTION_TO, };
 int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx,                                     enum AVHWFrameTransferDirection dir,                                     enum AVPixelFormat **formats, int flags);
 typedef struct AVHWFramesConstraints {     enum AVPixelFormat *valid_hw_formats;     enum AVPixelFormat *valid_sw_formats;     int min_width;     int min_height;     int max_width;     int max_height; } AVHWFramesConstraints;
 void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx);
 AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref,                                                            const void *hwconfig);
 void av_hwframe_constraints_free(AVHWFramesConstraints **constraints);
 enum {     AV_HWFRAME_MAP_READ = 1 << 0,     AV_HWFRAME_MAP_WRITE = 1 << 1,     AV_HWFRAME_MAP_OVERWRITE = 1 << 2,     AV_HWFRAME_MAP_DIRECT = 1 << 3, };
 int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags);
 int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx,                                   enum AVPixelFormat format,                                   AVBufferRef *derived_device_ctx,                                   AVBufferRef *source_frame_ctx,                                   int flags);
 enum AVCodecID {     AV_CODEC_ID_NONE,     AV_CODEC_ID_MPEG1VIDEO,     AV_CODEC_ID_MPEG2VIDEO,     AV_CODEC_ID_H261,     AV_CODEC_ID_H263,     AV_CODEC_ID_RV10,     AV_CODEC_ID_RV20,     AV_CODEC_ID_MJPEG,     AV_CODEC_ID_MJPEGB,     AV_CODEC_ID_LJPEG,     AV_CODEC_ID_SP5X,     AV_CODEC_ID_JPEGLS,     AV_CODEC_ID_MPEG4,     AV_CODEC_ID_RAWVIDEO,     AV_CODEC_ID_MSMPEG4V1,     AV_CODEC_ID_MSMPEG4V2,     AV_CODEC_ID_MSMPEG4V3,     AV_CODEC_ID_WMV1,     AV_CODEC_ID_WMV2,     AV_CODEC_ID_H263P,     AV_CODEC_ID_H263I,     AV_CODEC_ID_FLV1,     AV_CODEC_ID_SVQ1,     AV_CODEC_ID_SVQ3,     AV_CODEC_ID_DVVIDEO,     AV_CODEC_ID_HUFFYUV,     AV_CODEC_ID_CYUV,     AV_CODEC_ID_H264,     AV_CODEC_ID_INDEO3,     AV_CODEC_ID_VP3,     AV_CODEC_ID_THEORA,     AV_CODEC_ID_ASV1,     AV_CODEC_ID_ASV2,     AV_CODEC_ID_FFV1,     AV_CODEC_ID_4XM,     AV_CODEC_ID_VCR1,     AV_CODEC_ID_CLJR,     AV_CODEC_ID_MDEC,     AV_CODEC_ID_ROQ,     AV_CODEC_ID_INTERPLAY_VIDEO,     AV_CODEC_ID_XAN_WC3,     AV_CODEC_ID_XAN_WC4,     AV_CODEC_ID_RPZA,     AV_CODEC_ID_CINEPAK,     AV_CODEC_ID_WS_VQA,     AV_CODEC_ID_MSRLE,     AV_CODEC_ID_MSVIDEO1,     AV_CODEC_ID_IDCIN,     AV_CODEC_ID_8BPS,     AV_CODEC_ID_SMC,     AV_CODEC_ID_FLIC,     AV_CODEC_ID_TRUEMOTION1,     AV_CODEC_ID_VMDVIDEO,     AV_CODEC_ID_MSZH,     AV_CODEC_ID_ZLIB,     AV_CODEC_ID_QTRLE,     AV_CODEC_ID_TSCC,     AV_CODEC_ID_ULTI,     AV_CODEC_ID_QDRAW,     AV_CODEC_ID_VIXL,     AV_CODEC_ID_QPEG,     AV_CODEC_ID_PNG,     AV_CODEC_ID_PPM,     AV_CODEC_ID_PBM,     AV_CODEC_ID_PGM,     AV_CODEC_ID_PGMYUV,     AV_CODEC_ID_PAM,     AV_CODEC_ID_FFVHUFF,     AV_CODEC_ID_RV30,     AV_CODEC_ID_RV40,     AV_CODEC_ID_VC1,     AV_CODEC_ID_WMV3,     AV_CODEC_ID_LOCO,     AV_CODEC_ID_WNV1,     AV_CODEC_ID_AASC,     AV_CODEC_ID_INDEO2,     AV_CODEC_ID_FRAPS,     AV_CODEC_ID_TRUEMOTION2,     AV_CODEC_ID_BMP,     AV_CODEC_ID_CSCD,     AV_CODEC_ID_MMVIDEO,     AV_CODEC_ID_ZMBV,     AV_CODEC_ID_AVS,     AV_CODEC_ID_SMACKVIDEO,     AV_CODEC_ID_NUV,     AV_CODEC_ID_KMVC,     AV_CODEC_ID_FLASHSV,     AV_CODEC_ID_CAVS,     AV_CODEC_ID_JPEG2000,     AV_CODEC_ID_VMNC,     AV_CODEC_ID_VP5,     AV_CODEC_ID_VP6,     AV_CODEC_ID_VP6F,     AV_CODEC_ID_TARGA,     AV_CODEC_ID_DSICINVIDEO,     AV_CODEC_ID_TIERTEXSEQVIDEO,     AV_CODEC_ID_TIFF,     AV_CODEC_ID_GIF,     AV_CODEC_ID_DXA,     AV_CODEC_ID_DNXHD,     AV_CODEC_ID_THP,     AV_CODEC_ID_SGI,     AV_CODEC_ID_C93,     AV_CODEC_ID_BETHSOFTVID,     AV_CODEC_ID_PTX,     AV_CODEC_ID_TXD,     AV_CODEC_ID_VP6A,     AV_CODEC_ID_AMV,     AV_CODEC_ID_VB,     AV_CODEC_ID_PCX,     AV_CODEC_ID_SUNRAST,     AV_CODEC_ID_INDEO4,     AV_CODEC_ID_INDEO5,     AV_CODEC_ID_MIMIC,     AV_CODEC_ID_RL2,     AV_CODEC_ID_ESCAPE124,     AV_CODEC_ID_DIRAC,     AV_CODEC_ID_BFI,     AV_CODEC_ID_CMV,     AV_CODEC_ID_MOTIONPIXELS,     AV_CODEC_ID_TGV,     AV_CODEC_ID_TGQ,     AV_CODEC_ID_TQI,     AV_CODEC_ID_AURA,     AV_CODEC_ID_AURA2,     AV_CODEC_ID_V210X,     AV_CODEC_ID_TMV,     AV_CODEC_ID_V210,     AV_CODEC_ID_DPX,     AV_CODEC_ID_MAD,     AV_CODEC_ID_FRWU,     AV_CODEC_ID_FLASHSV2,     AV_CODEC_ID_CDGRAPHICS,     AV_CODEC_ID_R210,     AV_CODEC_ID_ANM,     AV_CODEC_ID_BINKVIDEO,     AV_CODEC_ID_IFF_ILBM,     AV_CODEC_ID_KGV1,     AV_CODEC_ID_YOP,     AV_CODEC_ID_VP8,     AV_CODEC_ID_PICTOR,     AV_CODEC_ID_ANSI,     AV_CODEC_ID_A64_MULTI,     AV_CODEC_ID_A64_MULTI5,     AV_CODEC_ID_R10K,     AV_CODEC_ID_MXPEG,     AV_CODEC_ID_LAGARITH,     AV_CODEC_ID_PRORES,     AV_CODEC_ID_JV,     AV_CODEC_ID_DFA,     AV_CODEC_ID_WMV3IMAGE,     AV_CODEC_ID_VC1IMAGE,     AV_CODEC_ID_UTVIDEO,     AV_CODEC_ID_BMV_VIDEO,     AV_CODEC_ID_VBLE,     AV_CODEC_ID_DXTORY,     AV_CODEC_ID_V410,     AV_CODEC_ID_XWD,     AV_CODEC_ID_CDXL,     AV_CODEC_ID_XBM,     AV_CODEC_ID_ZEROCODEC,     AV_CODEC_ID_MSS1,     AV_CODEC_ID_MSA1,     AV_CODEC_ID_TSCC2,     AV_CODEC_ID_MTS2,     AV_CODEC_ID_CLLC,     AV_CODEC_ID_MSS2,     AV_CODEC_ID_VP9,     AV_CODEC_ID_AIC,     AV_CODEC_ID_ESCAPE130,     AV_CODEC_ID_G2M,     AV_CODEC_ID_WEBP,     AV_CODEC_ID_HNM4_VIDEO,     AV_CODEC_ID_HEVC,     AV_CODEC_ID_FIC,     AV_CODEC_ID_ALIAS_PIX,     AV_CODEC_ID_BRENDER_PIX,     AV_CODEC_ID_PAF_VIDEO,     AV_CODEC_ID_EXR,     AV_CODEC_ID_VP7,     AV_CODEC_ID_SANM,     AV_CODEC_ID_SGIRLE,     AV_CODEC_ID_MVC1,     AV_CODEC_ID_MVC2,     AV_CODEC_ID_HQX,     AV_CODEC_ID_TDSC,     AV_CODEC_ID_HQ_HQA,     AV_CODEC_ID_HAP,     AV_CODEC_ID_DDS,     AV_CODEC_ID_DXV,     AV_CODEC_ID_SCREENPRESSO,     AV_CODEC_ID_RSCC,     AV_CODEC_ID_AVS2,     AV_CODEC_ID_PGX,     AV_CODEC_ID_AVS3,     AV_CODEC_ID_MSP2,     AV_CODEC_ID_VVC,     AV_CODEC_ID_Y41P,     AV_CODEC_ID_AVRP,     AV_CODEC_ID_012V,     AV_CODEC_ID_AVUI,     AV_CODEC_ID_TARGA_Y216,     AV_CODEC_ID_V308,     AV_CODEC_ID_V408,     AV_CODEC_ID_YUV4,     AV_CODEC_ID_AVRN,     AV_CODEC_ID_CPIA,     AV_CODEC_ID_XFACE,     AV_CODEC_ID_SNOW,     AV_CODEC_ID_SMVJPEG,     AV_CODEC_ID_APNG,     AV_CODEC_ID_DAALA,     AV_CODEC_ID_CFHD,     AV_CODEC_ID_TRUEMOTION2RT,     AV_CODEC_ID_M101,     AV_CODEC_ID_MAGICYUV,     AV_CODEC_ID_SHEERVIDEO,     AV_CODEC_ID_YLC,     AV_CODEC_ID_PSD,     AV_CODEC_ID_PIXLET,     AV_CODEC_ID_SPEEDHQ,     AV_CODEC_ID_FMVC,     AV_CODEC_ID_SCPR,     AV_CODEC_ID_CLEARVIDEO,     AV_CODEC_ID_XPM,     AV_CODEC_ID_AV1,     AV_CODEC_ID_BITPACKED,     AV_CODEC_ID_MSCC,     AV_CODEC_ID_SRGC,     AV_CODEC_ID_SVG,     AV_CODEC_ID_GDV,     AV_CODEC_ID_FITS,     AV_CODEC_ID_IMM4,     AV_CODEC_ID_PROSUMER,     AV_CODEC_ID_MWSC,     AV_CODEC_ID_WCMV,     AV_CODEC_ID_RASC,     AV_CODEC_ID_HYMT,     AV_CODEC_ID_ARBC,     AV_CODEC_ID_AGM,     AV_CODEC_ID_LSCR,     AV_CODEC_ID_VP4,     AV_CODEC_ID_IMM5,     AV_CODEC_ID_MVDV,     AV_CODEC_ID_MVHA,     AV_CODEC_ID_CDTOONS,     AV_CODEC_ID_MV30,     AV_CODEC_ID_NOTCHLC,     AV_CODEC_ID_PFM,     AV_CODEC_ID_MOBICLIP,     AV_CODEC_ID_PHOTOCD,     AV_CODEC_ID_IPU,     AV_CODEC_ID_ARGO,     AV_CODEC_ID_CRI,     AV_CODEC_ID_SIMBIOSIS_IMX,     AV_CODEC_ID_SGA_VIDEO,     AV_CODEC_ID_GEM,     AV_CODEC_ID_VBN,     AV_CODEC_ID_JPEGXL,     AV_CODEC_ID_QOI,     AV_CODEC_ID_PHM,     AV_CODEC_ID_RADIANCE_HDR,     AV_CODEC_ID_WBMP,     AV_CODEC_ID_MEDIA100,     AV_CODEC_ID_VQC,     AV_CODEC_ID_PDV,     AV_CODEC_ID_EVC,     AV_CODEC_ID_RTV1,     AV_CODEC_ID_VMIX,     AV_CODEC_ID_LEAD,     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     AV_CODEC_ID_PCM_S16LE = 0x10000,     AV_CODEC_ID_PCM_S16BE,     AV_CODEC_ID_PCM_U16LE,     AV_CODEC_ID_PCM_U16BE,     AV_CODEC_ID_PCM_S8,     AV_CODEC_ID_PCM_U8,     AV_CODEC_ID_PCM_MULAW,     AV_CODEC_ID_PCM_ALAW,     AV_CODEC_ID_PCM_S32LE,     AV_CODEC_ID_PCM_S32BE,     AV_CODEC_ID_PCM_U32LE,     AV_CODEC_ID_PCM_U32BE,     AV_CODEC_ID_PCM_S24LE,     AV_CODEC_ID_PCM_S24BE,     AV_CODEC_ID_PCM_U24LE,     AV_CODEC_ID_PCM_U24BE,     AV_CODEC_ID_PCM_S24DAUD,     AV_CODEC_ID_PCM_ZORK,     AV_CODEC_ID_PCM_S16LE_PLANAR,     AV_CODEC_ID_PCM_DVD,     AV_CODEC_ID_PCM_F32BE,     AV_CODEC_ID_PCM_F32LE,     AV_CODEC_ID_PCM_F64BE,     AV_CODEC_ID_PCM_F64LE,     AV_CODEC_ID_PCM_BLURAY,     AV_CODEC_ID_PCM_LXF,     AV_CODEC_ID_S302M,     AV_CODEC_ID_PCM_S8_PLANAR,     AV_CODEC_ID_PCM_S24LE_PLANAR,     AV_CODEC_ID_PCM_S32LE_PLANAR,     AV_CODEC_ID_PCM_S16BE_PLANAR,     AV_CODEC_ID_PCM_S64LE,     AV_CODEC_ID_PCM_S64BE,     AV_CODEC_ID_PCM_F16LE,     AV_CODEC_ID_PCM_F24LE,     AV_CODEC_ID_PCM_VIDC,     AV_CODEC_ID_PCM_SGA,     AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,     AV_CODEC_ID_ADPCM_IMA_WAV,     AV_CODEC_ID_ADPCM_IMA_DK3,     AV_CODEC_ID_ADPCM_IMA_DK4,     AV_CODEC_ID_ADPCM_IMA_WS,     AV_CODEC_ID_ADPCM_IMA_SMJPEG,     AV_CODEC_ID_ADPCM_MS,     AV_CODEC_ID_ADPCM_4XM,     AV_CODEC_ID_ADPCM_XA,     AV_CODEC_ID_ADPCM_ADX,     AV_CODEC_ID_ADPCM_EA,     AV_CODEC_ID_ADPCM_G726,     AV_CODEC_ID_ADPCM_CT,     AV_CODEC_ID_ADPCM_SWF,     AV_CODEC_ID_ADPCM_YAMAHA,     AV_CODEC_ID_ADPCM_SBPRO_4,     AV_CODEC_ID_ADPCM_SBPRO_3,     AV_CODEC_ID_ADPCM_SBPRO_2,     AV_CODEC_ID_ADPCM_THP,     AV_CODEC_ID_ADPCM_IMA_AMV,     AV_CODEC_ID_ADPCM_EA_R1,     AV_CODEC_ID_ADPCM_EA_R3,     AV_CODEC_ID_ADPCM_EA_R2,     AV_CODEC_ID_ADPCM_IMA_EA_SEAD,     AV_CODEC_ID_ADPCM_IMA_EA_EACS,     AV_CODEC_ID_ADPCM_EA_XAS,     AV_CODEC_ID_ADPCM_EA_MAXIS_XA,     AV_CODEC_ID_ADPCM_IMA_ISS,     AV_CODEC_ID_ADPCM_G722,     AV_CODEC_ID_ADPCM_IMA_APC,     AV_CODEC_ID_ADPCM_VIMA,     AV_CODEC_ID_ADPCM_AFC,     AV_CODEC_ID_ADPCM_IMA_OKI,     AV_CODEC_ID_ADPCM_DTK,     AV_CODEC_ID_ADPCM_IMA_RAD,     AV_CODEC_ID_ADPCM_G726LE,     AV_CODEC_ID_ADPCM_THP_LE,     AV_CODEC_ID_ADPCM_PSX,     AV_CODEC_ID_ADPCM_AICA,     AV_CODEC_ID_ADPCM_IMA_DAT4,     AV_CODEC_ID_ADPCM_MTAF,     AV_CODEC_ID_ADPCM_AGM,     AV_CODEC_ID_ADPCM_ARGO,     AV_CODEC_ID_ADPCM_IMA_SSI,     AV_CODEC_ID_ADPCM_ZORK,     AV_CODEC_ID_ADPCM_IMA_APM,     AV_CODEC_ID_ADPCM_IMA_ALP,     AV_CODEC_ID_ADPCM_IMA_MTF,     AV_CODEC_ID_ADPCM_IMA_CUNNING,     AV_CODEC_ID_ADPCM_IMA_MOFLEX,     AV_CODEC_ID_ADPCM_IMA_ACORN,     AV_CODEC_ID_ADPCM_XMD,     AV_CODEC_ID_AMR_NB = 0x12000,     AV_CODEC_ID_AMR_WB,     AV_CODEC_ID_RA_144 = 0x13000,     AV_CODEC_ID_RA_288,     AV_CODEC_ID_ROQ_DPCM = 0x14000,     AV_CODEC_ID_INTERPLAY_DPCM,     AV_CODEC_ID_XAN_DPCM,     AV_CODEC_ID_SOL_DPCM,     AV_CODEC_ID_SDX2_DPCM,     AV_CODEC_ID_GREMLIN_DPCM,     AV_CODEC_ID_DERF_DPCM,     AV_CODEC_ID_WADY_DPCM,     AV_CODEC_ID_CBD2_DPCM,     AV_CODEC_ID_MP2 = 0x15000,     AV_CODEC_ID_MP3,     AV_CODEC_ID_AAC,     AV_CODEC_ID_AC3,     AV_CODEC_ID_DTS,     AV_CODEC_ID_VORBIS,     AV_CODEC_ID_DVAUDIO,     AV_CODEC_ID_WMAV1,     AV_CODEC_ID_WMAV2,     AV_CODEC_ID_MACE3,     AV_CODEC_ID_MACE6,     AV_CODEC_ID_VMDAUDIO,     AV_CODEC_ID_FLAC,     AV_CODEC_ID_MP3ADU,     AV_CODEC_ID_MP3ON4,     AV_CODEC_ID_SHORTEN,     AV_CODEC_ID_ALAC,     AV_CODEC_ID_WESTWOOD_SND1,     AV_CODEC_ID_GSM,     AV_CODEC_ID_QDM2,     AV_CODEC_ID_COOK,     AV_CODEC_ID_TRUESPEECH,     AV_CODEC_ID_TTA,     AV_CODEC_ID_SMACKAUDIO,     AV_CODEC_ID_QCELP,     AV_CODEC_ID_WAVPACK,     AV_CODEC_ID_DSICINAUDIO,     AV_CODEC_ID_IMC,     AV_CODEC_ID_MUSEPACK7,     AV_CODEC_ID_MLP,     AV_CODEC_ID_GSM_MS,     AV_CODEC_ID_ATRAC3,     AV_CODEC_ID_APE,     AV_CODEC_ID_NELLYMOSER,     AV_CODEC_ID_MUSEPACK8,     AV_CODEC_ID_SPEEX,     AV_CODEC_ID_WMAVOICE,     AV_CODEC_ID_WMAPRO,     AV_CODEC_ID_WMALOSSLESS,     AV_CODEC_ID_ATRAC3P,     AV_CODEC_ID_EAC3,     AV_CODEC_ID_SIPR,     AV_CODEC_ID_MP1,     AV_CODEC_ID_TWINVQ,     AV_CODEC_ID_TRUEHD,     AV_CODEC_ID_MP4ALS,     AV_CODEC_ID_ATRAC1,     AV_CODEC_ID_BINKAUDIO_RDFT,     AV_CODEC_ID_BINKAUDIO_DCT,     AV_CODEC_ID_AAC_LATM,     AV_CODEC_ID_QDMC,     AV_CODEC_ID_CELT,     AV_CODEC_ID_G723_1,     AV_CODEC_ID_G729,     AV_CODEC_ID_8SVX_EXP,     AV_CODEC_ID_8SVX_FIB,     AV_CODEC_ID_BMV_AUDIO,     AV_CODEC_ID_RALF,     AV_CODEC_ID_IAC,     AV_CODEC_ID_ILBC,     AV_CODEC_ID_OPUS,     AV_CODEC_ID_COMFORT_NOISE,     AV_CODEC_ID_TAK,     AV_CODEC_ID_METASOUND,     AV_CODEC_ID_PAF_AUDIO,     AV_CODEC_ID_ON2AVC,     AV_CODEC_ID_DSS_SP,     AV_CODEC_ID_CODEC2,     AV_CODEC_ID_FFWAVESYNTH,     AV_CODEC_ID_SONIC,     AV_CODEC_ID_SONIC_LS,     AV_CODEC_ID_EVRC,     AV_CODEC_ID_SMV,     AV_CODEC_ID_DSD_LSBF,     AV_CODEC_ID_DSD_MSBF,     AV_CODEC_ID_DSD_LSBF_PLANAR,     AV_CODEC_ID_DSD_MSBF_PLANAR,     AV_CODEC_ID_4GV,     AV_CODEC_ID_INTERPLAY_ACM,     AV_CODEC_ID_XMA1,     AV_CODEC_ID_XMA2,     AV_CODEC_ID_DST,     AV_CODEC_ID_ATRAC3AL,     AV_CODEC_ID_ATRAC3PAL,     AV_CODEC_ID_DOLBY_E,     AV_CODEC_ID_APTX,     AV_CODEC_ID_APTX_HD,     AV_CODEC_ID_SBC,     AV_CODEC_ID_ATRAC9,     AV_CODEC_ID_HCOM,     AV_CODEC_ID_ACELP_KELVIN,     AV_CODEC_ID_MPEGH_3D_AUDIO,     AV_CODEC_ID_SIREN,     AV_CODEC_ID_HCA,     AV_CODEC_ID_FASTAUDIO,     AV_CODEC_ID_MSNSIREN,     AV_CODEC_ID_DFPWM,     AV_CODEC_ID_BONK,     AV_CODEC_ID_MISC4,     AV_CODEC_ID_APAC,     AV_CODEC_ID_FTR,     AV_CODEC_ID_WAVARC,     AV_CODEC_ID_RKA,     AV_CODEC_ID_AC4,     AV_CODEC_ID_OSQ,     AV_CODEC_ID_QOA,     AV_CODEC_ID_LC3,     AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,     AV_CODEC_ID_DVD_SUBTITLE = 0x17000,     AV_CODEC_ID_DVB_SUBTITLE,     AV_CODEC_ID_TEXT,     AV_CODEC_ID_XSUB,     AV_CODEC_ID_SSA,     AV_CODEC_ID_MOV_TEXT,     AV_CODEC_ID_HDMV_PGS_SUBTITLE,     AV_CODEC_ID_DVB_TELETEXT,     AV_CODEC_ID_SRT,     AV_CODEC_ID_MICRODVD,     AV_CODEC_ID_EIA_608,     AV_CODEC_ID_JACOSUB,     AV_CODEC_ID_SAMI,     AV_CODEC_ID_REALTEXT,     AV_CODEC_ID_STL,     AV_CODEC_ID_SUBVIEWER1,     AV_CODEC_ID_SUBVIEWER,     AV_CODEC_ID_SUBRIP,     AV_CODEC_ID_WEBVTT,     AV_CODEC_ID_MPL2,     AV_CODEC_ID_VPLAYER,     AV_CODEC_ID_PJS,     AV_CODEC_ID_ASS,     AV_CODEC_ID_HDMV_TEXT_SUBTITLE,     AV_CODEC_ID_TTML,     AV_CODEC_ID_ARIB_CAPTION,     AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,     AV_CODEC_ID_TTF = 0x18000,     AV_CODEC_ID_SCTE_35,     AV_CODEC_ID_EPG,     AV_CODEC_ID_BINTEXT,     AV_CODEC_ID_XBIN,     AV_CODEC_ID_IDF,     AV_CODEC_ID_OTF,     AV_CODEC_ID_SMPTE_KLV,     AV_CODEC_ID_DVD_NAV,     AV_CODEC_ID_TIMED_ID3,     AV_CODEC_ID_BIN_DATA,     AV_CODEC_ID_SMPTE_2038,     AV_CODEC_ID_LCEVC,     AV_CODEC_ID_PROBE = 0x19000,     AV_CODEC_ID_MPEG2TS = 0x20000,     AV_CODEC_ID_MPEG4SYSTEMS = 0x20001,     AV_CODEC_ID_FFMETADATA = 0x21000,     AV_CODEC_ID_WRAPPED_AVFRAME = 0x21001,     AV_CODEC_ID_VNULL,     AV_CODEC_ID_ANULL, };
 enum AVMediaType avcodec_get_type(enum AVCodecID codec_id);
 const char *avcodec_get_name(enum AVCodecID id);
 int av_get_bits_per_sample(enum AVCodecID codec_id);
 int av_get_exact_bits_per_sample(enum AVCodecID codec_id);
 const char *avcodec_profile_name(enum AVCodecID codec_id, int profile);
 enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be);
 typedef struct AVProfile {     int profile;     const char *name; } AVProfile;
 typedef struct AVCodec {     const char *name;     const char *long_name;     enum AVMediaType type;     enum AVCodecID id;     int capabilities;     uint8_t max_lowres;          const AVRational *supported_framerates;          const enum AVPixelFormat *pix_fmts;          const int *supported_samplerates;          const enum AVSampleFormat *sample_fmts;     const AVClass *priv_class;     const AVProfile *profiles;     const char *wrapper_name;          const AVChannelLayout *ch_layouts; } AVCodec;
 const AVCodec *av_codec_iterate(void **opaque);
 const AVCodec *avcodec_find_decoder(enum AVCodecID id);
 const AVCodec *avcodec_find_decoder_by_name(const char *name);
 const AVCodec *avcodec_find_encoder(enum AVCodecID id);
 const AVCodec *avcodec_find_encoder_by_name(const char *name);
 int av_codec_is_encoder(const AVCodec *codec);
 int av_codec_is_decoder(const AVCodec *codec);
 const char *av_get_profile_name(const AVCodec *codec, int profile);
 enum {     AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 0x01,     AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 0x02,     AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 0x04,     AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 0x08, };
 typedef struct AVCodecHWConfig {     enum AVPixelFormat pix_fmt;     int methods;     enum AVHWDeviceType device_type; } AVCodecHWConfig;
 const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index);
 enum AVFieldOrder {     AV_FIELD_UNKNOWN,     AV_FIELD_PROGRESSIVE,     AV_FIELD_TT,     AV_FIELD_BB,     AV_FIELD_TB,     AV_FIELD_BT, };
 enum AVDiscard{     AVDISCARD_NONE =-16,     AVDISCARD_DEFAULT = 0,     AVDISCARD_NONREF = 8,     AVDISCARD_BIDIR = 16,     AVDISCARD_NONINTRA= 24,     AVDISCARD_NONKEY = 32,     AVDISCARD_ALL = 48, };
 enum AVAudioServiceType {     AV_AUDIO_SERVICE_TYPE_MAIN = 0,     AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,     AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,     AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,     AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,     AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,     AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,     AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,     AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,     AV_AUDIO_SERVICE_TYPE_NB , };
 typedef struct AVPanScan {     int id;     int width;     int height;     int16_t position[3][2]; } AVPanScan;
 typedef struct AVCPBProperties {     int64_t max_bitrate;     int64_t min_bitrate;     int64_t avg_bitrate;     int64_t buffer_size;     uint64_t vbv_delay; } AVCPBProperties;
 AVCPBProperties *av_cpb_properties_alloc(size_t *size);
 typedef struct AVProducerReferenceTime {     int64_t wallclock;     int flags; } AVProducerReferenceTime;
 unsigned int av_xiphlacing(unsigned char *s, unsigned int v);
 enum AVPacketSideDataType {     AV_PKT_DATA_PALETTE,     AV_PKT_DATA_NEW_EXTRADATA,     AV_PKT_DATA_PARAM_CHANGE,     AV_PKT_DATA_H263_MB_INFO,     AV_PKT_DATA_REPLAYGAIN,     AV_PKT_DATA_DISPLAYMATRIX,     AV_PKT_DATA_STEREO3D,     AV_PKT_DATA_AUDIO_SERVICE_TYPE,     AV_PKT_DATA_QUALITY_STATS,     AV_PKT_DATA_FALLBACK_TRACK,     AV_PKT_DATA_CPB_PROPERTIES,     AV_PKT_DATA_SKIP_SAMPLES,     AV_PKT_DATA_JP_DUALMONO,     AV_PKT_DATA_STRINGS_METADATA,     AV_PKT_DATA_SUBTITLE_POSITION,     AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,     AV_PKT_DATA_WEBVTT_IDENTIFIER,     AV_PKT_DATA_WEBVTT_SETTINGS,     AV_PKT_DATA_METADATA_UPDATE,     AV_PKT_DATA_MPEGTS_STREAM_ID,     AV_PKT_DATA_MASTERING_DISPLAY_METADATA,     AV_PKT_DATA_SPHERICAL,     AV_PKT_DATA_CONTENT_LIGHT_LEVEL,     AV_PKT_DATA_A53_CC,     AV_PKT_DATA_ENCRYPTION_INIT_INFO,     AV_PKT_DATA_ENCRYPTION_INFO,     AV_PKT_DATA_AFD,     AV_PKT_DATA_PRFT,     AV_PKT_DATA_ICC_PROFILE,     AV_PKT_DATA_DOVI_CONF,     AV_PKT_DATA_S12M_TIMECODE,     AV_PKT_DATA_DYNAMIC_HDR10_PLUS,     AV_PKT_DATA_IAMF_MIX_GAIN_PARAM,     AV_PKT_DATA_IAMF_DEMIXING_INFO_PARAM,     AV_PKT_DATA_IAMF_RECON_GAIN_INFO_PARAM,     AV_PKT_DATA_AMBIENT_VIEWING_ENVIRONMENT,     AV_PKT_DATA_FRAME_CROPPING,     AV_PKT_DATA_LCEVC,     AV_PKT_DATA_NB };
 typedef struct AVPacketSideData {     uint8_t *data;     size_t size;     enum AVPacketSideDataType type; } AVPacketSideData;
 AVPacketSideData *av_packet_side_data_new(AVPacketSideData **psd, int *pnb_sd,                                           enum AVPacketSideDataType type,                                           size_t size, int flags);
 AVPacketSideData *av_packet_side_data_add(AVPacketSideData **sd, int *nb_sd,                                           enum AVPacketSideDataType type,                                           void *data, size_t size, int flags);
 const AVPacketSideData *av_packet_side_data_get(const AVPacketSideData *sd,                                                 int nb_sd,                                                 enum AVPacketSideDataType type);
 void av_packet_side_data_remove(AVPacketSideData *sd, int *nb_sd,                                 enum AVPacketSideDataType type);
 void av_packet_side_data_free(AVPacketSideData **sd, int *nb_sd);
 const char *av_packet_side_data_name(enum AVPacketSideDataType type);
 typedef struct AVPacket {     AVBufferRef *buf;     int64_t pts;     int64_t dts;     uint8_t *data;     int size;     int stream_index;     int flags;     AVPacketSideData *side_data;     int side_data_elems;     int64_t duration;     int64_t pos;     void *opaque;     AVBufferRef *opaque_ref;     AVRational time_base; } AVPacket;
  typedef struct AVPacketList {     AVPacket pkt;     struct AVPacketList *next; } AVPacketList;
 enum AVSideDataParamChangeFlags {     AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 0x0004,     AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 0x0008, };
 AVPacket *av_packet_alloc(void);
 AVPacket *av_packet_clone(const AVPacket *src);
 void av_packet_free(AVPacket **pkt);
  void av_init_packet(AVPacket *pkt);
 int av_new_packet(AVPacket *pkt, int size);
 void av_shrink_packet(AVPacket *pkt, int size);
 int av_grow_packet(AVPacket *pkt, int grow_by);
 int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size);
 uint8_t* av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,                                  size_t size);
 int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type,                             uint8_t *data, size_t size);
 int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type,                                size_t size);
 uint8_t* av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type,                                  size_t *size);
 uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size);
 int av_packet_unpack_dictionary(const uint8_t *data, size_t size,                                 AVDictionary **dict);
 void av_packet_free_side_data(AVPacket *pkt);
 int av_packet_ref(AVPacket *dst, const AVPacket *src);
 void av_packet_unref(AVPacket *pkt);
 void av_packet_move_ref(AVPacket *dst, AVPacket *src);
 int av_packet_copy_props(AVPacket *dst, const AVPacket *src);
 int av_packet_make_refcounted(AVPacket *pkt);
 int av_packet_make_writable(AVPacket *pkt);
 void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst);
 typedef struct AVCodecDescriptor {     enum AVCodecID id;     enum AVMediaType type;     const char *name;     const char *long_name;     int props;     const char *const *mime_types;     const struct AVProfile *profiles; } AVCodecDescriptor;
 const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id);
 const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev);
 const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name);
 typedef struct AVCodecParameters {     enum AVMediaType codec_type;     enum AVCodecID codec_id;     uint32_t codec_tag;     uint8_t *extradata;     int extradata_size;     AVPacketSideData *coded_side_data;     int nb_coded_side_data;     int format;     int64_t bit_rate;     int bits_per_coded_sample;     int bits_per_raw_sample;     int profile;     int level;     int width;     int height;     AVRational sample_aspect_ratio;     AVRational framerate;     enum AVFieldOrder field_order;     enum AVColorRange color_range;     enum AVColorPrimaries color_primaries;     enum AVColorTransferCharacteristic color_trc;     enum AVColorSpace color_space;     enum AVChromaLocation chroma_location;     int video_delay;     AVChannelLayout ch_layout;     int sample_rate;     int block_align;     int frame_size;     int initial_padding;     int trailing_padding;     int seek_preroll; } AVCodecParameters;
 AVCodecParameters *avcodec_parameters_alloc(void);
 void avcodec_parameters_free(AVCodecParameters **par);
 int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src);
 int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes);
 struct AVCodecParameters;
 typedef struct RcOverride{     int start_frame;     int end_frame;     int qscale;     float quality_factor; } RcOverride;
 typedef struct AVCodecContext {     const AVClass *av_class;     int log_level_offset;     enum AVMediaType codec_type;     const struct AVCodec *codec;     enum AVCodecID codec_id;     unsigned int codec_tag;     void *priv_data;     struct AVCodecInternal *internal;     void *opaque;     int64_t bit_rate;     int flags;     int flags2;     uint8_t *extradata;     int extradata_size;     AVRational time_base;     AVRational pkt_timebase;     AVRational framerate;          int ticks_per_frame;     int delay;     int width, height;     int coded_width, coded_height;     AVRational sample_aspect_ratio;     enum AVPixelFormat pix_fmt;     enum AVPixelFormat sw_pix_fmt;     enum AVColorPrimaries color_primaries;     enum AVColorTransferCharacteristic color_trc;     enum AVColorSpace colorspace;     enum AVColorRange color_range;     enum AVChromaLocation chroma_sample_location;     enum AVFieldOrder field_order;     int refs;     int has_b_frames;     int slice_flags;     void (*draw_horiz_band)(struct AVCodecContext *s,                             const AVFrame *src, int offset[8],                             int y, int type, int height);     enum AVPixelFormat (*get_format)(struct AVCodecContext *s, const enum AVPixelFormat * fmt);     int max_b_frames;     float b_quant_factor;     float b_quant_offset;     float i_quant_factor;     float i_quant_offset;     float lumi_masking;     float temporal_cplx_masking;     float spatial_cplx_masking;     float p_masking;     float dark_masking;      int nsse_weight;     int me_cmp;     int me_sub_cmp;     int mb_cmp;     int ildct_cmp;     int dia_size;     int last_predictor_count;     int me_pre_cmp;     int pre_dia_size;     int me_subpel_quality;     int me_range;     int mb_decision;     uint16_t *intra_matrix;     uint16_t *inter_matrix;     uint16_t *chroma_intra_matrix;     int intra_dc_precision;     int mb_lmin;     int mb_lmax;     int bidir_refine;     int keyint_min;     int gop_size;     int mv0_threshold;     int slices;     int sample_rate;     enum AVSampleFormat sample_fmt;     AVChannelLayout ch_layout;     int frame_size;     int block_align;     int cutoff;     enum AVAudioServiceType audio_service_type;     enum AVSampleFormat request_sample_fmt;     int initial_padding;     int trailing_padding;     int seek_preroll;     int (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, int flags);     int bit_rate_tolerance;     int global_quality;     int compression_level;     float qcompress;     float qblur;     int qmin;     int qmax;     int max_qdiff;     int rc_buffer_size;     int rc_override_count;     RcOverride *rc_override;     int64_t rc_max_rate;     int64_t rc_min_rate;     float rc_max_available_vbv_use;     float rc_min_vbv_overflow_use;     int rc_initial_buffer_occupancy;     int trellis;     char *stats_out;     char *stats_in;     int workaround_bugs;     int strict_std_compliance;     int error_concealment;     int debug;     int err_recognition;     const struct AVHWAccel *hwaccel;     void *hwaccel_context;     AVBufferRef *hw_frames_ctx;     AVBufferRef *hw_device_ctx;     int hwaccel_flags;     int extra_hw_frames;     uint64_t error[8];     int dct_algo;     int idct_algo;      int bits_per_coded_sample;     int bits_per_raw_sample;     int thread_count;     int thread_type;     int active_thread_type;     int (*execute)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg), void *arg2, int *ret, int count, int size);     int (*execute2)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count);      int profile;      int level;     unsigned properties;     enum AVDiscard skip_loop_filter;     enum AVDiscard skip_idct;     enum AVDiscard skip_frame;     int skip_alpha;     int skip_top;     int skip_bottom;      int lowres;     const struct AVCodecDescriptor *codec_descriptor;     char *sub_charenc;     int sub_charenc_mode;     int subtitle_header_size;     uint8_t *subtitle_header;     uint8_t *dump_separator;     char *codec_whitelist;     AVPacketSideData *coded_side_data;     int nb_coded_side_data;     int export_side_data;     int64_t max_pixels;     int apply_cropping;     int discard_damaged_percentage;     int64_t max_samples;     int (*get_encode_buffer)(struct AVCodecContext *s, AVPacket *pkt, int flags);     int64_t frame_num;     int *side_data_prefer_packet;     unsigned nb_side_data_prefer_packet;     AVFrameSideData **decoded_side_data;     int nb_decoded_side_data; } AVCodecContext;
 typedef struct AVHWAccel {     const char *name;     enum AVMediaType type;     enum AVCodecID id;     enum AVPixelFormat pix_fmt;     int capabilities; } AVHWAccel;
 enum AVSubtitleType {     SUBTITLE_NONE,     SUBTITLE_BITMAP,     SUBTITLE_TEXT,     SUBTITLE_ASS, };
 typedef struct AVSubtitleRect {     int x;     int y;     int w;     int h;     int nb_colors;     uint8_t *data[4];     int linesize[4];     int flags;     enum AVSubtitleType type;     char *text;     char *ass; } AVSubtitleRect;
 typedef struct AVSubtitle {     uint16_t format;     uint32_t start_display_time;     uint32_t end_display_time;     unsigned num_rects;     AVSubtitleRect **rects;     int64_t pts; } AVSubtitle;
 unsigned avcodec_version(void);
 const char *avcodec_configuration(void);
 const char *avcodec_license(void);
 AVCodecContext *avcodec_alloc_context3(const AVCodec *codec);
 void avcodec_free_context(AVCodecContext **avctx);
 const AVClass *avcodec_get_class(void);
 const AVClass *avcodec_get_subtitle_rect_class(void);
 int avcodec_parameters_from_context(struct AVCodecParameters *par,                                     const AVCodecContext *codec);
 int avcodec_parameters_to_context(AVCodecContext *codec,                                   const struct AVCodecParameters *par);
 int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);
  int avcodec_close(AVCodecContext *avctx);
 void avsubtitle_free(AVSubtitle *sub);
 int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags);
 int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags);
 void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height);
 void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,                                int linesize_align[8]);
 int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,                              int *got_sub_ptr, const AVPacket *avpkt);
 int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt);
 int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame);
 int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame);
 int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt);
 int avcodec_get_hw_frames_parameters(AVCodecContext *avctx,                                      AVBufferRef *device_ref,                                      enum AVPixelFormat hw_pix_fmt,                                      AVBufferRef **out_frames_ref);
 enum AVCodecConfig {     AV_CODEC_CONFIG_PIX_FORMAT,     AV_CODEC_CONFIG_FRAME_RATE,     AV_CODEC_CONFIG_SAMPLE_RATE,     AV_CODEC_CONFIG_SAMPLE_FORMAT,     AV_CODEC_CONFIG_CHANNEL_LAYOUT,     AV_CODEC_CONFIG_COLOR_RANGE,     AV_CODEC_CONFIG_COLOR_SPACE, };
 int avcodec_get_supported_config(const AVCodecContext *avctx,                                  const AVCodec *codec, enum AVCodecConfig config,                                  unsigned flags, const void **out_configs,                                  int *out_num_configs);
 enum AVPictureStructure {     AV_PICTURE_STRUCTURE_UNKNOWN,     AV_PICTURE_STRUCTURE_TOP_FIELD,     AV_PICTURE_STRUCTURE_BOTTOM_FIELD,     AV_PICTURE_STRUCTURE_FRAME, };
 typedef struct AVCodecParserContext {     void *priv_data;     const struct AVCodecParser *parser;     int64_t frame_offset;     int64_t cur_offset;     int64_t next_frame_offset;     int pict_type;     int repeat_pict;     int64_t pts;     int64_t dts;     int64_t last_pts;     int64_t last_dts;     int fetch_timestamp;     int cur_frame_start_index;     int64_t cur_frame_offset[4];     int64_t cur_frame_pts[4];     int64_t cur_frame_dts[4];     int flags;     int64_t offset;     int64_t cur_frame_end[4];     int key_frame;     int dts_sync_point;     int dts_ref_dts_delta;     int pts_dts_delta;     int64_t cur_frame_pos[4];     int64_t pos;     int64_t last_pos;     int duration;     enum AVFieldOrder field_order;     enum AVPictureStructure picture_structure;     int output_picture_number;     int width;     int height;     int coded_width;     int coded_height;     int format; } AVCodecParserContext;
 typedef struct AVCodecParser {     int codec_ids[7];     int priv_data_size;     int (*parser_init)(AVCodecParserContext *s);     int (*parser_parse)(AVCodecParserContext *s,                         AVCodecContext *avctx,                         const uint8_t **poutbuf, int *poutbuf_size,                         const uint8_t *buf, int buf_size);     void (*parser_close)(AVCodecParserContext *s);     int (*split)(AVCodecContext *avctx, const uint8_t *buf, int buf_size); } AVCodecParser;
 const AVCodecParser *av_parser_iterate(void **opaque);
 AVCodecParserContext *av_parser_init(int codec_id);
 int av_parser_parse2(AVCodecParserContext *s,                      AVCodecContext *avctx,                      uint8_t **poutbuf, int *poutbuf_size,                      const uint8_t *buf, int buf_size,                      int64_t pts, int64_t dts,                      int64_t pos);
 void av_parser_close(AVCodecParserContext *s);
 int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,                             const AVSubtitle *sub);
 unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt);
 enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list,                                             enum AVPixelFormat src_pix_fmt,                                             int has_alpha, int *loss_ptr);
 enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
 void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode);
 int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2),void *arg, int *ret, int count, int size);
 int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int, int),void *arg, int *ret, int count);
 int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,                              enum AVSampleFormat sample_fmt, const uint8_t *buf,                              int buf_size, int align);
 void avcodec_flush_buffers(AVCodecContext *avctx);
 int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes);
 void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size);
 void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size);
 int avcodec_is_open(AVCodecContext *s);
 unsigned avfilter_version(void);
 const char *avfilter_configuration(void);
 const char *avfilter_license(void);
 typedef struct AVFilterContext AVFilterContext;
 typedef struct AVFilterLink AVFilterLink;
 typedef struct AVFilterPad AVFilterPad;
 typedef struct AVFilterFormats AVFilterFormats;
 typedef struct AVFilterChannelLayouts AVFilterChannelLayouts;
 const char *avfilter_pad_get_name(const AVFilterPad *pads, int pad_idx);
 enum AVMediaType avfilter_pad_get_type(const AVFilterPad *pads, int pad_idx);
 typedef struct AVFilterFormatsConfig {     AVFilterFormats *formats;     AVFilterFormats *samplerates;     AVFilterChannelLayouts *channel_layouts;     AVFilterFormats *color_spaces;     AVFilterFormats *color_ranges; } AVFilterFormatsConfig;
 typedef struct AVFilter {     const char *name;     const char *description;     const AVFilterPad *inputs;     const AVFilterPad *outputs;     const AVClass *priv_class;     int flags;     uint8_t nb_inputs;     uint8_t nb_outputs;     uint8_t formats_state;     int (*preinit)(AVFilterContext *ctx);     int (*init)(AVFilterContext *ctx);     void (*uninit)(AVFilterContext *ctx);     union {         int (*query_func)(AVFilterContext *);         int (*query_func2)(const AVFilterContext *,                            struct AVFilterFormatsConfig **cfg_in,                            struct AVFilterFormatsConfig **cfg_out);         const enum AVPixelFormat *pixels_list;         const enum AVSampleFormat *samples_list;         enum AVPixelFormat pix_fmt;         enum AVSampleFormat sample_fmt;     } formats;     int priv_size;     int flags_internal;     int (*process_command)(AVFilterContext *, const char *cmd, const char *arg, char *res, int res_len, int flags);     int (*activate)(AVFilterContext *ctx); } AVFilter;
 unsigned avfilter_filter_pad_count(const AVFilter *filter, int is_output);
 struct AVFilterContext {     const AVClass *av_class;     const AVFilter *filter;     char *name;     AVFilterPad *input_pads;     AVFilterLink **inputs;     unsigned nb_inputs;     AVFilterPad *output_pads;     AVFilterLink **outputs;     unsigned nb_outputs;     void *priv;     struct AVFilterGraph *graph;     int thread_type;     int nb_threads;     struct AVFilterCommand *command_queue;     char *enable_str;     void *enable;     double *var_values;     int is_disabled;     AVBufferRef *hw_device_ctx;     unsigned ready;     int extra_hw_frames; };
 struct AVFilterLink {     AVFilterContext *src;     AVFilterPad *srcpad;     AVFilterContext *dst;     AVFilterPad *dstpad;     enum AVMediaType type;     int format;     int w;     int h;     AVRational sample_aspect_ratio;     enum AVColorSpace colorspace;     enum AVColorRange color_range;     int sample_rate;     AVChannelLayout ch_layout;     AVRational time_base;     AVFilterFormatsConfig incfg;     AVFilterFormatsConfig outcfg; };
 int avfilter_link(AVFilterContext *src, unsigned srcpad,                   AVFilterContext *dst, unsigned dstpad);
  void avfilter_link_free(AVFilterLink **link);
  int avfilter_config_links(AVFilterContext *filter);
 int avfilter_process_command(AVFilterContext *filter, const char *cmd, const char *arg, char *res, int res_len, int flags);
 const AVFilter *av_filter_iterate(void **opaque);
 const AVFilter *avfilter_get_by_name(const char *name);
 int avfilter_init_str(AVFilterContext *ctx, const char *args);
 int avfilter_init_dict(AVFilterContext *ctx, AVDictionary **options);
 void avfilter_free(AVFilterContext *filter);
 int avfilter_insert_filter(AVFilterLink *link, AVFilterContext *filt,                            unsigned filt_srcpad_idx, unsigned filt_dstpad_idx);
 const AVClass *avfilter_get_class(void);
 typedef int (avfilter_action_func)(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs);
 typedef int (avfilter_execute_func)(AVFilterContext *ctx, avfilter_action_func *func,                                     void *arg, int *ret, int nb_jobs);
 typedef struct AVFilterGraph {     const AVClass *av_class;     AVFilterContext **filters;     unsigned nb_filters;     char *scale_sws_opts;     int thread_type;     int nb_threads;     void *opaque;     avfilter_execute_func *execute;     char *aresample_swr_opts; } AVFilterGraph;
 AVFilterGraph *avfilter_graph_alloc(void);
 AVFilterContext *avfilter_graph_alloc_filter(AVFilterGraph *graph,                                              const AVFilter *filter,                                              const char *name);
 AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, const char *name);
 int avfilter_graph_create_filter(AVFilterContext **filt_ctx, const AVFilter *filt,                                  const char *name, const char *args, void *opaque,                                  AVFilterGraph *graph_ctx);
 void avfilter_graph_set_auto_convert(AVFilterGraph *graph, unsigned flags);
 enum {     AVFILTER_AUTO_CONVERT_ALL = 0,     AVFILTER_AUTO_CONVERT_NONE = -1, };
 int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx);
 void avfilter_graph_free(AVFilterGraph **graph);
 typedef struct AVFilterInOut {     char *name;     AVFilterContext *filter_ctx;     int pad_idx;     struct AVFilterInOut *next; } AVFilterInOut;
 AVFilterInOut *avfilter_inout_alloc(void);
 void avfilter_inout_free(AVFilterInOut **inout);
 int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,                          AVFilterInOut *inputs, AVFilterInOut *outputs,                          void *log_ctx);
 int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters,                              AVFilterInOut **inputs, AVFilterInOut **outputs,                              void *log_ctx);
 int avfilter_graph_parse2(AVFilterGraph *graph, const char *filters,                           AVFilterInOut **inputs,                           AVFilterInOut **outputs);
 typedef struct AVFilterPadParams {     char *label; } AVFilterPadParams;
 typedef struct AVFilterParams {     AVFilterContext *filter;     char *filter_name;     char *instance_name;     AVDictionary *opts;     AVFilterPadParams **inputs;     unsigned nb_inputs;     AVFilterPadParams **outputs;     unsigned nb_outputs; } AVFilterParams;
 typedef struct AVFilterChain {     AVFilterParams **filters;     size_t nb_filters; } AVFilterChain;
 typedef struct AVFilterGraphSegment {     AVFilterGraph *graph;     AVFilterChain **chains;     size_t nb_chains;     char *scale_sws_opts; } AVFilterGraphSegment;
 int avfilter_graph_segment_parse(AVFilterGraph *graph, const char *graph_str,                                  int flags, AVFilterGraphSegment **seg);
 int avfilter_graph_segment_create_filters(AVFilterGraphSegment *seg, int flags);
 int avfilter_graph_segment_apply_opts(AVFilterGraphSegment *seg, int flags);
 int avfilter_graph_segment_init(AVFilterGraphSegment *seg, int flags);
 int avfilter_graph_segment_link(AVFilterGraphSegment *seg, int flags,                                 AVFilterInOut **inputs,                                 AVFilterInOut **outputs);
 int avfilter_graph_segment_apply(AVFilterGraphSegment *seg, int flags,                                  AVFilterInOut **inputs,                                  AVFilterInOut **outputs);
 void avfilter_graph_segment_free(AVFilterGraphSegment **seg);
 int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags);
 int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, int flags, double ts);
 char *avfilter_graph_dump(AVFilterGraph *graph, const char *options);
 int avfilter_graph_request_oldest(AVFilterGraph *graph);
 typedef struct AVIOInterruptCB {     int (*callback)(void*);     void *opaque; } AVIOInterruptCB;
 enum AVIODirEntryType {     AVIO_ENTRY_UNKNOWN,     AVIO_ENTRY_BLOCK_DEVICE,     AVIO_ENTRY_CHARACTER_DEVICE,     AVIO_ENTRY_DIRECTORY,     AVIO_ENTRY_NAMED_PIPE,     AVIO_ENTRY_SYMBOLIC_LINK,     AVIO_ENTRY_SOCKET,     AVIO_ENTRY_FILE,     AVIO_ENTRY_SERVER,     AVIO_ENTRY_SHARE,     AVIO_ENTRY_WORKGROUP, };
 typedef struct AVIODirEntry {     char *name;     int type;     int utf8;     int64_t size;     int64_t modification_timestamp;     int64_t access_timestamp;     int64_t status_change_timestamp;     int64_t user_id;     int64_t group_id;     int64_t filemode; } AVIODirEntry;
 typedef struct AVIODirContext AVIODirContext;
 enum AVIODataMarkerType {     AVIO_DATA_MARKER_HEADER,     AVIO_DATA_MARKER_SYNC_POINT,     AVIO_DATA_MARKER_BOUNDARY_POINT,     AVIO_DATA_MARKER_UNKNOWN,     AVIO_DATA_MARKER_TRAILER,     AVIO_DATA_MARKER_FLUSH_POINT, };
 typedef struct AVIOContext {     const AVClass *av_class;     unsigned char *buffer;     int buffer_size;     unsigned char *buf_ptr;     unsigned char *buf_end;     void *opaque;     int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);     int (*write_packet)(void *opaque, const uint8_t *buf, int buf_size);     int64_t (*seek)(void *opaque, int64_t offset, int whence);     int64_t pos;     int eof_reached;     int error;     int write_flag;     int max_packet_size;     int min_packet_size;     unsigned long checksum;     unsigned char *checksum_ptr;     unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);     int (*read_pause)(void *opaque, int pause);     int64_t (*read_seek)(void *opaque, int stream_index,                          int64_t timestamp, int flags);     int seekable;     int direct;     const char *protocol_whitelist;     const char *protocol_blacklist;     int (*write_data_type)(void *opaque, const uint8_t *buf, int buf_size,                            enum AVIODataMarkerType type, int64_t time);     int ignore_boundary_point;     unsigned char *buf_ptr_max;     int64_t bytes_read;     int64_t bytes_written; } AVIOContext;
 const char *avio_find_protocol_name(const char *url);
 int avio_check(const char *url, int flags);
 int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options);
 int avio_read_dir(AVIODirContext *s, AVIODirEntry **next);
 int avio_close_dir(AVIODirContext **s);
 void avio_free_directory_entry(AVIODirEntry **entry);
 AVIOContext *avio_alloc_context(                   unsigned char *buffer,                   int buffer_size,                   int write_flag,                   void *opaque,                   int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),                   int (*write_packet)(void *opaque, const uint8_t *buf, int buf_size),                   int64_t (*seek)(void *opaque, int64_t offset, int whence));
 void avio_context_free(AVIOContext **s);
 void avio_w8(AVIOContext *s, int b);
 void avio_write(AVIOContext *s, const unsigned char *buf, int size);
 void avio_wl64(AVIOContext *s, uint64_t val);
 void avio_wb64(AVIOContext *s, uint64_t val);
 void avio_wl32(AVIOContext *s, unsigned int val);
 void avio_wb32(AVIOContext *s, unsigned int val);
 void avio_wl24(AVIOContext *s, unsigned int val);
 void avio_wb24(AVIOContext *s, unsigned int val);
 void avio_wl16(AVIOContext *s, unsigned int val);
 void avio_wb16(AVIOContext *s, unsigned int val);
 int avio_put_str(AVIOContext *s, const char *str);
 int avio_put_str16le(AVIOContext *s, const char *str);
 int avio_put_str16be(AVIOContext *s, const char *str);
 void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type);
 int64_t avio_seek(AVIOContext *s, int64_t offset, int whence);
 int64_t avio_skip(AVIOContext *s, int64_t offset);
 static  inline int64_t avio_tell(AVIOContext *s) {     return avio_seek(s, 0,                            1                                   ); }
 int64_t avio_size(AVIOContext *s);
 int avio_feof(AVIOContext *s);
 int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap);
 void avio_print_string_array(AVIOContext *s, const char * const strings[]);
 void avio_flush(AVIOContext *s);
 int avio_read(AVIOContext *s, unsigned char *buf, int size);
 int avio_read_partial(AVIOContext *s, unsigned char *buf, int size);
 int avio_r8 (AVIOContext *s);
 unsigned int avio_rl16(AVIOContext *s);
 unsigned int avio_rl24(AVIOContext *s);
 unsigned int avio_rl32(AVIOContext *s);
 uint64_t avio_rl64(AVIOContext *s);
 unsigned int avio_rb16(AVIOContext *s);
 unsigned int avio_rb24(AVIOContext *s);
 unsigned int avio_rb32(AVIOContext *s);
 uint64_t avio_rb64(AVIOContext *s);
 int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen);
 int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen);
 int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen);
 int avio_open(AVIOContext **s, const char *url, int flags);
 int avio_open2(AVIOContext **s, const char *url, int flags,                const AVIOInterruptCB *int_cb, AVDictionary **options);
 int avio_close(AVIOContext *s);
 int avio_closep(AVIOContext **s);
 int avio_open_dyn_buf(AVIOContext **s);
 int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer);
 int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer);
 const char *avio_enum_protocols(void **opaque, int output);
 const AVClass *avio_protocol_get_class(const char *name);
 int avio_pause(AVIOContext *h, int pause);
 int64_t avio_seek_time(AVIOContext *h, int stream_index,                        int64_t timestamp, int flags);
 struct AVBPrint;
 int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size);
 int avio_accept(AVIOContext *s, AVIOContext **c);
 int avio_handshake(AVIOContext *c);
 struct AVFormatContext;
 struct AVFrame;
 int av_get_packet(AVIOContext *s, AVPacket *pkt, int size);
 int av_append_packet(AVIOContext *s, AVPacket *pkt, int size);
 struct AVCodecTag;
 typedef struct AVProbeData {     const char *filename;     unsigned char *buf;     int buf_size;     const char *mime_type; } AVProbeData;
 typedef struct AVOutputFormat {     const char *name;     const char *long_name;     const char *mime_type;     const char *extensions;     enum AVCodecID audio_codec;     enum AVCodecID video_codec;     enum AVCodecID subtitle_codec;     int flags;     const struct AVCodecTag * const *codec_tag;     const AVClass *priv_class; } AVOutputFormat;
 typedef struct AVInputFormat {     const char *name;     const char *long_name;     int flags;     const char *extensions;     const struct AVCodecTag * const *codec_tag;     const AVClass *priv_class;     const char *mime_type; } AVInputFormat;
 enum AVStreamParseType {     AVSTREAM_PARSE_NONE,     AVSTREAM_PARSE_FULL,     AVSTREAM_PARSE_HEADERS,     AVSTREAM_PARSE_TIMESTAMPS,     AVSTREAM_PARSE_FULL_ONCE,     AVSTREAM_PARSE_FULL_RAW, };
 typedef struct AVIndexEntry {     int64_t pos;     int64_t timestamp;     int flags:2;     int size:30;     int min_distance; } AVIndexEntry;
 int av_disposition_from_string(const char *disp);
 const char *av_disposition_to_string(int disposition);
 typedef struct AVStream {     const AVClass *av_class;     int index;     int id;     AVCodecParameters *codecpar;     void *priv_data;     AVRational time_base;     int64_t start_time;     int64_t duration;     int64_t nb_frames;     int disposition;     enum AVDiscard discard;     AVRational sample_aspect_ratio;     AVDictionary *metadata;     AVRational avg_frame_rate;     AVPacket attached_pic;          AVPacketSideData *side_data;          int nb_side_data;     int event_flags;     AVRational r_frame_rate;     int pts_wrap_bits; } AVStream;
 typedef struct AVStreamGroupTileGrid {     const AVClass *av_class;     unsigned int nb_tiles;     int coded_width;     int coded_height;     struct {         unsigned int idx;         int horizontal;         int vertical;     } *offsets;     uint8_t background[4];     int horizontal_offset;     int vertical_offset;     int width;     int height; } AVStreamGroupTileGrid;
 typedef struct AVStreamGroupLCEVC {     const AVClass *av_class;     unsigned int lcevc_index;     int width;     int height; } AVStreamGroupLCEVC;
 enum AVStreamGroupParamsType {     AV_STREAM_GROUP_PARAMS_NONE,     AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT,     AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION,     AV_STREAM_GROUP_PARAMS_TILE_GRID,     AV_STREAM_GROUP_PARAMS_LCEVC, };
 struct AVIAMFAudioElement;
 struct AVIAMFMixPresentation;
 typedef struct AVStreamGroup {     const AVClass *av_class;     void *priv_data;     unsigned int index;     int64_t id;     enum AVStreamGroupParamsType type;     union {         struct AVIAMFAudioElement *iamf_audio_element;         struct AVIAMFMixPresentation *iamf_mix_presentation;         struct AVStreamGroupTileGrid *tile_grid;         struct AVStreamGroupLCEVC *lcevc;     } params;     AVDictionary *metadata;     unsigned int nb_streams;     AVStream **streams;     int disposition; } AVStreamGroup;
 struct AVCodecParserContext *av_stream_get_parser(const AVStream *s);
 typedef struct AVProgram {     int id;     int flags;     enum AVDiscard discard;     unsigned int *stream_index;     unsigned int nb_stream_indexes;     AVDictionary *metadata;     int program_num;     int pmt_pid;     int pcr_pid;     int pmt_version;     int64_t start_time;     int64_t end_time;     int64_t pts_wrap_reference;     int pts_wrap_behavior; } AVProgram;
 typedef struct AVChapter {     int64_t id;     AVRational time_base;     int64_t start, end;     AVDictionary *metadata; } AVChapter;
 typedef int (*av_format_control_message)(struct AVFormatContext *s, int type,                                          void *data, size_t data_size);
 typedef int (*AVOpenCallback)(struct AVFormatContext *s, AVIOContext **pb, const char *url, int flags,                               const AVIOInterruptCB *int_cb, AVDictionary **options);
 enum AVDurationEstimationMethod {     AVFMT_DURATION_FROM_PTS,     AVFMT_DURATION_FROM_STREAM,     AVFMT_DURATION_FROM_BITRATE };
 typedef struct AVFormatContext {     const AVClass *av_class;     const struct AVInputFormat *iformat;     const struct AVOutputFormat *oformat;     void *priv_data;     AVIOContext *pb;     int ctx_flags;     unsigned int nb_streams;     AVStream **streams;     unsigned int nb_stream_groups;     AVStreamGroup **stream_groups;     unsigned int nb_chapters;     AVChapter **chapters;     char *url;     int64_t start_time;     int64_t duration;     int64_t bit_rate;     unsigned int packet_size;     int max_delay;     int flags;     int64_t probesize;     int64_t max_analyze_duration;     const uint8_t *key;     int keylen;     unsigned int nb_programs;     AVProgram **programs;     enum AVCodecID video_codec_id;     enum AVCodecID audio_codec_id;     enum AVCodecID subtitle_codec_id;     enum AVCodecID data_codec_id;     AVDictionary *metadata;     int64_t start_time_realtime;     int fps_probe_size;     int error_recognition;     AVIOInterruptCB interrupt_callback;     int debug;     int max_streams;     unsigned int max_index_size;     unsigned int max_picture_buffer;     int64_t max_interleave_delta;     int max_ts_probe;     int max_chunk_duration;     int max_chunk_size;     int max_probe_packets;     int strict_std_compliance;     int event_flags;     int avoid_negative_ts;     int audio_preload;     int use_wallclock_as_timestamps;     int skip_estimate_duration_from_pts;     int avio_flags;     enum AVDurationEstimationMethod duration_estimation_method;     int64_t skip_initial_bytes;     unsigned int correct_ts_overflow;     int seek2any;     int flush_packets;     int probe_score;     int format_probesize;     char *codec_whitelist;     char *format_whitelist;     char *protocol_whitelist;     char *protocol_blacklist;     int io_repositioned;     const struct AVCodec *video_codec;     const struct AVCodec *audio_codec;     const struct AVCodec *subtitle_codec;     const struct AVCodec *data_codec;     int metadata_header_padding;     void *opaque;     av_format_control_message control_message_cb;     int64_t output_ts_offset;     uint8_t *dump_separator;     int (*io_open)(struct AVFormatContext *s, AVIOContext **pb, const char *url,                    int flags, AVDictionary **options);     int (*io_close2)(struct AVFormatContext *s, AVIOContext *pb);     int64_t duration_probesize; } AVFormatContext;
 void av_format_inject_global_side_data(AVFormatContext *s);
  enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext* ctx);
 unsigned avformat_version(void);
 const char *avformat_configuration(void);
 const char *avformat_license(void);
 int avformat_network_init(void);
 int avformat_network_deinit(void);
 const AVOutputFormat *av_muxer_iterate(void **opaque);
 const AVInputFormat *av_demuxer_iterate(void **opaque);
 AVFormatContext *avformat_alloc_context(void);
 void avformat_free_context(AVFormatContext *s);
 const AVClass *avformat_get_class(void);
 const AVClass *av_stream_get_class(void);
 const AVClass *av_stream_group_get_class(void);
 const char *avformat_stream_group_name(enum AVStreamGroupParamsType type);
 AVStreamGroup *avformat_stream_group_create(AVFormatContext *s,                                             enum AVStreamGroupParamsType type,                                             AVDictionary **options);
 AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c);
 int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st);
  int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type,                             uint8_t *data, size_t size);
  uint8_t *av_stream_new_side_data(AVStream *stream,                                  enum AVPacketSideDataType type, size_t size);
  uint8_t *av_stream_get_side_data(const AVStream *stream,                                  enum AVPacketSideDataType type, size_t *size);
 AVProgram *av_new_program(AVFormatContext *s, int id);
 int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat,                                    const char *format_name, const char *filename);
 const AVInputFormat *av_find_input_format(const char *short_name);
 const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened);
 const AVInputFormat *av_probe_input_format2(const AVProbeData *pd,                                             int is_opened, int *score_max);
 const AVInputFormat *av_probe_input_format3(const AVProbeData *pd,                                             int is_opened, int *score_ret);
 int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt,                            const char *url, void *logctx,                            unsigned int offset, unsigned int max_probe_size);
 int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt,                           const char *url, void *logctx,                           unsigned int offset, unsigned int max_probe_size);
 int avformat_open_input(AVFormatContext **ps, const char *url,                         const AVInputFormat *fmt, AVDictionary **options);
 int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);
 AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s);
 void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx);
 int av_find_best_stream(AVFormatContext *ic,                         enum AVMediaType type,                         int wanted_stream_nb,                         int related_stream,                         const struct AVCodec **decoder_ret,                         int flags);
 int av_read_frame(AVFormatContext *s, AVPacket *pkt);
 int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp,                   int flags);
 int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags);
 int avformat_flush(AVFormatContext *s);
 int av_read_play(AVFormatContext *s);
 int av_read_pause(AVFormatContext *s);
 void avformat_close_input(AVFormatContext **s);
  int avformat_write_header(AVFormatContext *s, AVDictionary **options);
  int avformat_init_output(AVFormatContext *s, AVDictionary **options);
 int av_write_frame(AVFormatContext *s, AVPacket *pkt);
 int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);
 int av_write_uncoded_frame(AVFormatContext *s, int stream_index,                            struct AVFrame *frame);
 int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index,                                        struct AVFrame *frame);
 int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index);
 int av_write_trailer(AVFormatContext *s);
 const AVOutputFormat *av_guess_format(const char *short_name,                                       const char *filename,                                       const char *mime_type);
 enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name,                               const char *filename, const char *mime_type,                               enum AVMediaType type);
 int av_get_output_timestamp(struct AVFormatContext *s, int stream,                             int64_t *dts, int64_t *wall);
 void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size);
 void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload,                       const AVStream *st);
 enum AVCodecID av_codec_get_id(const struct AVCodecTag * const *tags, unsigned int tag);
 unsigned int av_codec_get_tag(const struct AVCodecTag * const *tags, enum AVCodecID id);
 int av_codec_get_tag2(const struct AVCodecTag * const *tags, enum AVCodecID id,                       unsigned int *tag);
 int av_find_default_stream_index(AVFormatContext *s);
 int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags);
 int avformat_index_get_entries_count(const AVStream *st);
 const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx);
 const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st,                                                             int64_t wanted_timestamp,                                                             int flags);
 int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,                        int size, int distance, int flags);
 void av_url_split(char *proto, int proto_size,                   char *authorization, int authorization_size,                   char *hostname, int hostname_size,                   int *port_ptr,                   char *path, int path_size,                   const char *url);
 void av_dump_format(AVFormatContext *ic,                     int index,                     const char *url,                     int is_output);
 int av_get_frame_filename2(char *buf, int buf_size,                           const char *path, int number, int flags);
 int av_get_frame_filename(char *buf, int buf_size,                           const char *path, int number);
 int av_filename_number_test(const char *filename);
 int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size);
 int av_match_ext(const char *filename, const char *extensions);
 int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id,                          int std_compliance);
 const struct AVCodecTag *avformat_get_riff_video_tags(void);
 const struct AVCodecTag *avformat_get_riff_audio_tags(void);
 const struct AVCodecTag *avformat_get_mov_video_tags(void);
 const struct AVCodecTag *avformat_get_mov_audio_tags(void);
 AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream,                                         struct AVFrame *frame);
 AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream,                                struct AVFrame *frame);
 int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st,                                     const char *spec);
 int avformat_queue_attached_pictures(AVFormatContext *s);
 enum AVTimebaseSource {     AVFMT_TBCF_AUTO = -1,     AVFMT_TBCF_DECODER,     AVFMT_TBCF_DEMUXER,     AVFMT_TBCF_R_FRAMERATE, };
  int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt,                                                   AVStream *ost, const AVStream *ist,                                                   enum AVTimebaseSource copy_tb);
  AVRational av_stream_get_codec_timebase(const AVStream *st);
 enum AVOptionType{     AV_OPT_TYPE_FLAGS = 1,     AV_OPT_TYPE_INT,     AV_OPT_TYPE_INT64,     AV_OPT_TYPE_DOUBLE,     AV_OPT_TYPE_FLOAT,     AV_OPT_TYPE_STRING,     AV_OPT_TYPE_RATIONAL,     AV_OPT_TYPE_BINARY,     AV_OPT_TYPE_DICT,     AV_OPT_TYPE_UINT64,     AV_OPT_TYPE_CONST,     AV_OPT_TYPE_IMAGE_SIZE,     AV_OPT_TYPE_PIXEL_FMT,     AV_OPT_TYPE_SAMPLE_FMT,     AV_OPT_TYPE_VIDEO_RATE,     AV_OPT_TYPE_DURATION,     AV_OPT_TYPE_COLOR,     AV_OPT_TYPE_BOOL,     AV_OPT_TYPE_CHLAYOUT,     AV_OPT_TYPE_UINT,     AV_OPT_TYPE_FLAG_ARRAY = (1 << 16), };
 typedef struct AVOptionArrayDef {     const char *def;     unsigned size_min;     unsigned size_max;     char sep; } AVOptionArrayDef;
 typedef struct AVOption {     const char *name;     const char *help;     int offset;     enum AVOptionType type;     union {         int64_t i64;         double dbl;         const char *str;         AVRational q;         const AVOptionArrayDef *arr;     } default_val;     double min;     double max;     int flags;     const char *unit; } AVOption;
 typedef struct AVOptionRange {     const char *str;     double value_min, value_max;     double component_min, component_max;     int is_range; } AVOptionRange;
 typedef struct AVOptionRanges {     AVOptionRange **range;     int nb_ranges;     int nb_components; } AVOptionRanges;
 void av_opt_set_defaults(void *s);
 void av_opt_set_defaults2(void *s, int mask, int flags);
 void av_opt_free(void *obj);
 const AVOption *av_opt_next(const void *obj, const AVOption *prev);
 void *av_opt_child_next(void *obj, void *prev);
 const AVClass *av_opt_child_class_iterate(const AVClass *parent, void **iter);
 const AVOption *av_opt_find(void *obj, const char *name, const char *unit,                             int opt_flags, int search_flags);
 const AVOption *av_opt_find2(void *obj, const char *name, const char *unit,                              int opt_flags, int search_flags, void **target_obj);
 int av_opt_show2(void *obj, void *av_log_obj, int req_flags, int rej_flags);
 int av_opt_get_key_value(const char **ropts,                          const char *key_val_sep, const char *pairs_sep,                          unsigned flags,                          char **rkey, char **rval);
 enum {     AV_OPT_FLAG_IMPLICIT_KEY = 1, };
 int av_set_options_string(void *ctx, const char *opts,                           const char *key_val_sep, const char *pairs_sep);
 int av_opt_set_from_string(void *ctx, const char *opts,                            const char *const *shorthand,                            const char *key_val_sep, const char *pairs_sep);
 int av_opt_set_dict(void *obj, struct AVDictionary **options);
 int av_opt_set_dict2(void *obj, struct AVDictionary **options, int search_flags);
 int av_opt_copy(void *dest, const void *src);
 int av_opt_set (void *obj, const char *name, const char *val, int search_flags);
 int av_opt_set_int (void *obj, const char *name, int64_t val, int search_flags);
 int av_opt_set_double (void *obj, const char *name, double val, int search_flags);
 int av_opt_set_q (void *obj, const char *name, AVRational val, int search_flags);
 int av_opt_set_bin (void *obj, const char *name, const uint8_t *val, int size, int search_flags);
 int av_opt_set_image_size(void *obj, const char *name, int w, int h, int search_flags);
 int av_opt_set_pixel_fmt (void *obj, const char *name, enum AVPixelFormat fmt, int search_flags);
 int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags);
 int av_opt_set_video_rate(void *obj, const char *name, AVRational val, int search_flags);
 int av_opt_set_chlayout(void *obj, const char *name, const AVChannelLayout *layout, int search_flags);
 int av_opt_set_dict_val(void *obj, const char *name, const AVDictionary *val, int search_flags);
 int av_opt_set_array(void *obj, const char *name, int search_flags,                      unsigned int start_elem, unsigned int nb_elems,                      enum AVOptionType val_type, const void *val);
 int av_opt_get (void *obj, const char *name, int search_flags, uint8_t **out_val);
 int av_opt_get_int (void *obj, const char *name, int search_flags, int64_t *out_val);
 int av_opt_get_double (void *obj, const char *name, int search_flags, double *out_val);
 int av_opt_get_q (void *obj, const char *name, int search_flags, AVRational *out_val);
 int av_opt_get_image_size(void *obj, const char *name, int search_flags, int *w_out, int *h_out);
 int av_opt_get_pixel_fmt (void *obj, const char *name, int search_flags, enum AVPixelFormat *out_fmt);
 int av_opt_get_sample_fmt(void *obj, const char *name, int search_flags, enum AVSampleFormat *out_fmt);
 int av_opt_get_video_rate(void *obj, const char *name, int search_flags, AVRational *out_val);
 int av_opt_get_chlayout(void *obj, const char *name, int search_flags, AVChannelLayout *layout);
 int av_opt_get_dict_val(void *obj, const char *name, int search_flags, AVDictionary **out_val);
 int av_opt_get_array_size(void *obj, const char *name, int search_flags,                           unsigned int *out_val);
 int av_opt_get_array(void *obj, const char *name, int search_flags,                      unsigned int start_elem, unsigned int nb_elems,                      enum AVOptionType out_type, void *out_val);
 int av_opt_eval_flags (void *obj, const AVOption *o, const char *val, int *flags_out);
 int av_opt_eval_int (void *obj, const AVOption *o, const char *val, int *int_out);
 int av_opt_eval_uint (void *obj, const AVOption *o, const char *val, unsigned *uint_out);
 int av_opt_eval_int64 (void *obj, const AVOption *o, const char *val, int64_t *int64_out);
 int av_opt_eval_float (void *obj, const AVOption *o, const char *val, float *float_out);
 int av_opt_eval_double(void *obj, const AVOption *o, const char *val, double *double_out);
 int av_opt_eval_q (void *obj, const AVOption *o, const char *val, AVRational *q_out);
 void *av_opt_ptr(const AVClass *avclass, void *obj, const char *name);
 int av_opt_is_set_to_default(void *obj, const AVOption *o);
 int av_opt_is_set_to_default_by_name(void *obj, const char *name, int search_flags);
 int av_opt_flag_is_set(void *obj, const char *field_name, const char *flag_name);
 int av_opt_serialize(void *obj, int opt_flags, int flags, char **buffer,                      const char key_val_sep, const char pairs_sep);
 void av_opt_freep_ranges(AVOptionRanges **ranges);
 int av_opt_query_ranges(AVOptionRanges **, void *obj, const char *key, int flags);
 int av_opt_query_ranges_default(AVOptionRanges **, void *obj, const char *key, int flags);
 unsigned avdevice_version(void);
 const char *avdevice_configuration(void);
 const char *avdevice_license(void);
 void avdevice_register_all(void);
 const AVInputFormat *av_input_audio_device_next(const AVInputFormat *d);
 const AVInputFormat *av_input_video_device_next(const AVInputFormat *d);
 const AVOutputFormat *av_output_audio_device_next(const AVOutputFormat *d);
 const AVOutputFormat *av_output_video_device_next(const AVOutputFormat *d);
 typedef struct AVDeviceRect {     int x;     int y;     int width;     int height; } AVDeviceRect;
 enum AVAppToDevMessageType {     AV_APP_TO_DEV_NONE = (('E') | (('N') << 8) | (('O') << 16) | ((unsigned)('N') << 24)),     AV_APP_TO_DEV_WINDOW_SIZE = (('M') | (('O') << 8) | (('E') << 16) | ((unsigned)('G') << 24)),     AV_APP_TO_DEV_WINDOW_REPAINT = (('A') | (('P') << 8) | (('E') << 16) | ((unsigned)('R') << 24)),     AV_APP_TO_DEV_PAUSE = ((' ') | (('U') << 8) | (('A') << 16) | ((unsigned)('P') << 24)),     AV_APP_TO_DEV_PLAY = (('Y') | (('A') << 8) | (('L') << 16) | ((unsigned)('P') << 24)),     AV_APP_TO_DEV_TOGGLE_PAUSE = (('T') | (('U') << 8) | (('A') << 16) | ((unsigned)('P') << 24)),     AV_APP_TO_DEV_SET_VOLUME = (('L') | (('O') << 8) | (('V') << 16) | ((unsigned)('S') << 24)),     AV_APP_TO_DEV_MUTE = (('T') | (('U') << 8) | (('M') << 16) | ((unsigned)(' ') << 24)),     AV_APP_TO_DEV_UNMUTE = (('T') | (('U') << 8) | (('M') << 16) | ((unsigned)('U') << 24)),     AV_APP_TO_DEV_TOGGLE_MUTE = (('T') | (('U') << 8) | (('M') << 16) | ((unsigned)('T') << 24)),     AV_APP_TO_DEV_GET_VOLUME = (('L') | (('O') << 8) | (('V') << 16) | ((unsigned)('G') << 24)),     AV_APP_TO_DEV_GET_MUTE = (('T') | (('U') << 8) | (('M') << 16) | ((unsigned)('G') << 24)), };
 enum AVDevToAppMessageType {     AV_DEV_TO_APP_NONE = (('E') | (('N') << 8) | (('O') << 16) | ((unsigned)('N') << 24)),     AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = (('E') | (('R') << 8) | (('C') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = (('E') | (('R') << 8) | (('P') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = (('S') | (('I') << 8) | (('D') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = (('S') | (('E') << 8) | (('D') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_BUFFER_OVERFLOW = (('L') | (('F') << 8) | (('O') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_BUFFER_UNDERFLOW = (('L') | (('F') << 8) | (('U') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_BUFFER_READABLE = ((' ') | (('D') << 8) | (('R') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_BUFFER_WRITABLE = ((' ') | (('R') << 8) | (('W') << 16) | ((unsigned)('B') << 24)),     AV_DEV_TO_APP_MUTE_STATE_CHANGED = (('T') | (('U') << 8) | (('M') << 16) | ((unsigned)('C') << 24)),     AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = (('L') | (('O') << 8) | (('V') << 16) | ((unsigned)('C') << 24)), };
 int avdevice_app_to_dev_control_message(struct AVFormatContext *s,                                         enum AVAppToDevMessageType type,                                         void *data, size_t data_size);
 int avdevice_dev_to_app_control_message(struct AVFormatContext *s,                                         enum AVDevToAppMessageType type,                                         void *data, size_t data_size);
 typedef struct AVDeviceInfo {     char *device_name;     char *device_description;     enum AVMediaType *media_types;     int nb_media_types; } AVDeviceInfo;
 typedef struct AVDeviceInfoList {     AVDeviceInfo **devices;     int nb_devices;     int default_device; } AVDeviceInfoList;
 int avdevice_list_devices(struct AVFormatContext *s, AVDeviceInfoList **device_list);
 void avdevice_free_list_devices(AVDeviceInfoList **device_list);
 int avdevice_list_input_sources(const AVInputFormat *device, const char *device_name,                                 AVDictionary *device_options, AVDeviceInfoList **device_list);
 int avdevice_list_output_sinks(const AVOutputFormat *device, const char *device_name,                                AVDictionary *device_options, AVDeviceInfoList **device_list);
 unsigned swscale_version(void);
 const char *swscale_configuration(void);
 const char *swscale_license(void);
 const int *sws_getCoefficients(int colorspace);
 typedef struct SwsVector {     double *coeff;     int length; } SwsVector;
 typedef struct SwsFilter {     SwsVector *lumH;     SwsVector *lumV;     SwsVector *chrH;     SwsVector *chrV; } SwsFilter;
 struct SwsContext;
 int sws_isSupportedInput(enum AVPixelFormat pix_fmt);
 int sws_isSupportedOutput(enum AVPixelFormat pix_fmt);
 int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt);
 struct SwsContext *sws_alloc_context(void);
  int sws_init_context(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter);
 void sws_freeContext(struct SwsContext *swsContext);
 struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat,                                   int dstW, int dstH, enum AVPixelFormat dstFormat,                                   int flags, SwsFilter *srcFilter,                                   SwsFilter *dstFilter, const double *param);
 int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[],               const int srcStride[], int srcSliceY, int srcSliceH,               uint8_t *const dst[], const int dstStride[]);
 int sws_scale_frame(struct SwsContext *c, AVFrame *dst, const AVFrame *src);
 int sws_frame_start(struct SwsContext *c, AVFrame *dst, const AVFrame *src);
 void sws_frame_end(struct SwsContext *c);
 int sws_send_slice(struct SwsContext *c, unsigned int slice_start,                    unsigned int slice_height);
 int sws_receive_slice(struct SwsContext *c, unsigned int slice_start,                       unsigned int slice_height);
 unsigned int sws_receive_slice_alignment(const struct SwsContext *c);
 int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4],                              int srcRange, const int table[4], int dstRange,                              int brightness, int contrast, int saturation);
 int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table,                              int *srcRange, int **table, int *dstRange,                              int *brightness, int *contrast, int *saturation);
 SwsVector *sws_allocVec(int length);
 SwsVector *sws_getGaussianVec(double variance, double quality);
 void sws_scaleVec(SwsVector *a, double scalar);
 void sws_normalizeVec(SwsVector *a, double height);
 void sws_freeVec(SwsVector *a);
 SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur,                                 float lumaSharpen, float chromaSharpen,                                 float chromaHShift, float chromaVShift,                                 int verbose);
 void sws_freeFilter(SwsFilter *filter);
 struct SwsContext *sws_getCachedContext(struct SwsContext *context,                                         int srcW, int srcH, enum AVPixelFormat srcFormat,                                         int dstW, int dstH, enum AVPixelFormat dstFormat,                                         int flags, SwsFilter *srcFilter,                                         SwsFilter *dstFilter, const double *param);
 void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette);
 void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette);
 const AVClass *sws_get_class(void);
